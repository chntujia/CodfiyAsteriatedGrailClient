// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base.proto

#ifndef PROTOBUF_base_2eproto__INCLUDED
#define PROTOBUF_base_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "action_respond.pb.h"
// @@protoc_insertion_point(includes)

namespace network {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_base_2eproto();
void protobuf_AssignDesc_base_2eproto();
void protobuf_ShutdownFile_base_2eproto();

class RegisterRequest;
class RegisterResponse;
class LoginRequest;
class LoginResponse;
class LogoutRequest;
class LogoutResponse;
class RoomListRequest;
class RoomListResponse;
class RoomListResponse_RoomInfo;
class CreateRoomRequest;
class EnterRoomRequest;
class LeaveRoomRequest;
class JoinTeamRequest;
class ReadyForGameRequest;
class SinglePlayerInfo;
class GameInfo;
class Talk;
class Error;
class Gossip;
class HeartBeat;

enum JoinTeamRequest_Team {
  JoinTeamRequest_Team_TEAM_A = 1,
  JoinTeamRequest_Team_TEAM_B = 0,
  JoinTeamRequest_Team_TEAM_RANDOM = 2
};
bool JoinTeamRequest_Team_IsValid(int value);
const JoinTeamRequest_Team JoinTeamRequest_Team_Team_MIN = JoinTeamRequest_Team_TEAM_B;
const JoinTeamRequest_Team JoinTeamRequest_Team_Team_MAX = JoinTeamRequest_Team_TEAM_RANDOM;
const int JoinTeamRequest_Team_Team_ARRAYSIZE = JoinTeamRequest_Team_Team_MAX + 1;

const ::google::protobuf::EnumDescriptor* JoinTeamRequest_Team_descriptor();
inline const ::std::string& JoinTeamRequest_Team_Name(JoinTeamRequest_Team value) {
  return ::google::protobuf::internal::NameOfEnum(
    JoinTeamRequest_Team_descriptor(), value);
}
inline bool JoinTeamRequest_Team_Parse(
    const ::std::string& name, JoinTeamRequest_Team* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JoinTeamRequest_Team>(
    JoinTeamRequest_Team_descriptor(), name, value);
}
enum ReadyForGameRequest_Type {
  ReadyForGameRequest_Type_START_READY = 1,
  ReadyForGameRequest_Type_CANCEL_START_REDAY = 2,
  ReadyForGameRequest_Type_SEAT_READY = 3
};
bool ReadyForGameRequest_Type_IsValid(int value);
const ReadyForGameRequest_Type ReadyForGameRequest_Type_Type_MIN = ReadyForGameRequest_Type_START_READY;
const ReadyForGameRequest_Type ReadyForGameRequest_Type_Type_MAX = ReadyForGameRequest_Type_SEAT_READY;
const int ReadyForGameRequest_Type_Type_ARRAYSIZE = ReadyForGameRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReadyForGameRequest_Type_descriptor();
inline const ::std::string& ReadyForGameRequest_Type_Name(ReadyForGameRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReadyForGameRequest_Type_descriptor(), value);
}
inline bool ReadyForGameRequest_Type_Parse(
    const ::std::string& name, ReadyForGameRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReadyForGameRequest_Type>(
    ReadyForGameRequest_Type_descriptor(), name, value);
}
enum MessageType {
  MSG_REGISTER_REQ = 1,
  MSG_REGISTER_REP = 2,
  MSG_LOGIN_REQ = 3,
  MSG_LOGIN_REP = 4,
  MSG_LOGOUT_REQ = 5,
  MSG_LOGOUT_REP = 6,
  MSG_ROOMLIST_REQ = 7,
  MSG_ROOMLIST_REP = 8,
  MSG_CREATE_ROOM_REQ = 9,
  MSG_ENTER_ROOM_REQ = 10,
  MSG_ENTER_ROOM_REP = 11,
  MSG_LEAVE_ROOM_REQ = 12,
  MSG_JOIN_TEAM_REQ = 13,
  MSG_READY_GAME_REQ = 14,
  MSG_SINGLE_PLAYER = 15,
  MSG_GAME = 16,
  MSG_TALK = 17,
  MSG_GOSSIP = 18,
  MSG_ERROR = 19,
  MSG_HEARTBEAT = 20
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = MSG_REGISTER_REQ;
const MessageType MessageType_MAX = MSG_HEARTBEAT;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum GossipType {
  GOSSIP_TALK = 1,
  GOSSIP_NOTICE = 2
};
bool GossipType_IsValid(int value);
const GossipType GossipType_MIN = GOSSIP_TALK;
const GossipType GossipType_MAX = GOSSIP_NOTICE;
const int GossipType_ARRAYSIZE = GossipType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GossipType_descriptor();
inline const ::std::string& GossipType_Name(GossipType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GossipType_descriptor(), value);
}
inline bool GossipType_Parse(
    const ::std::string& name, GossipType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GossipType>(
    GossipType_descriptor(), name, value);
}
// ===================================================================

class RegisterRequest : public ::google::protobuf::Message {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  void Swap(RegisterRequest* other);

  // implements Message ----------------------------------------------

  RegisterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional string user_password = 2;
  inline bool has_user_password() const;
  inline void clear_user_password();
  static const int kUserPasswordFieldNumber = 2;
  inline const ::std::string& user_password() const;
  inline void set_user_password(const ::std::string& value);
  inline void set_user_password(const char* value);
  inline void set_user_password(const char* value, size_t size);
  inline ::std::string* mutable_user_password();
  inline ::std::string* release_user_password();
  inline void set_allocated_user_password(::std::string* user_password);

  // optional string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string mobile = 4;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 4;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // optional string email = 5;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 5;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:network.RegisterRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_password();
  inline void clear_has_user_password();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_email();
  inline void clear_has_email();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_id_;
  ::std::string* user_password_;
  ::std::string* nickname_;
  ::std::string* mobile_;
  ::std::string* email_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RegisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterResponse : public ::google::protobuf::Message {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponse& default_instance();

  void Swap(RegisterResponse* other);

  // implements Message ----------------------------------------------

  RegisterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:network.RegisterResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RegisterResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool asGuest = 1;
  inline bool has_asguest() const;
  inline void clear_asguest();
  static const int kAsGuestFieldNumber = 1;
  inline bool asguest() const;
  inline void set_asguest(bool value);

  // optional string user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional string user_password = 3;
  inline bool has_user_password() const;
  inline void clear_user_password();
  static const int kUserPasswordFieldNumber = 3;
  inline const ::std::string& user_password() const;
  inline void set_user_password(const ::std::string& value);
  inline void set_user_password(const char* value);
  inline void set_user_password(const char* value, size_t size);
  inline ::std::string* mutable_user_password();
  inline ::std::string* release_user_password();
  inline void set_allocated_user_password(::std::string* user_password);

  // optional int32 version = 4 [default = -1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.LoginRequest)
 private:
  inline void set_has_asguest();
  inline void clear_has_asguest();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_password();
  inline void clear_has_user_password();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_id_;
  bool asguest_;
  ::google::protobuf::int32 version_;
  ::std::string* user_password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:network.LoginResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nickname_;
  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogoutRequest : public ::google::protobuf::Message {
 public:
  LogoutRequest();
  virtual ~LogoutRequest();

  LogoutRequest(const LogoutRequest& from);

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRequest& default_instance();

  void Swap(LogoutRequest* other);

  // implements Message ----------------------------------------------

  LogoutRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:network.LogoutRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LogoutRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogoutResponse : public ::google::protobuf::Message {
 public:
  LogoutResponse();
  virtual ~LogoutResponse();

  LogoutResponse(const LogoutResponse& from);

  inline LogoutResponse& operator=(const LogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutResponse& default_instance();

  void Swap(LogoutResponse* other);

  // implements Message ----------------------------------------------

  LogoutResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutResponse& from);
  void MergeFrom(const LogoutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 args = 1;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 1;
  inline ::google::protobuf::uint32 args(int index) const;
  inline void set_args(int index, ::google::protobuf::uint32 value);
  inline void add_args(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      args() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_args();

  // @@protoc_insertion_point(class_scope:network.LogoutResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LogoutResponse* default_instance_;
};
// -------------------------------------------------------------------

class RoomListRequest : public ::google::protobuf::Message {
 public:
  RoomListRequest();
  virtual ~RoomListRequest();

  RoomListRequest(const RoomListRequest& from);

  inline RoomListRequest& operator=(const RoomListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListRequest& default_instance();

  void Swap(RoomListRequest* other);

  // implements Message ----------------------------------------------

  RoomListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListRequest& from);
  void MergeFrom(const RoomListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .network.ROLE_STRATEGY role_strategy = 1;
  inline bool has_role_strategy() const;
  inline void clear_role_strategy();
  static const int kRoleStrategyFieldNumber = 1;
  inline ::network::ROLE_STRATEGY role_strategy() const;
  inline void set_role_strategy(::network::ROLE_STRATEGY value);

  // @@protoc_insertion_point(class_scope:network.RoomListRequest)
 private:
  inline void set_has_role_strategy();
  inline void clear_has_role_strategy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int role_strategy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RoomListRequest* default_instance_;
};
// -------------------------------------------------------------------

class RoomListResponse_RoomInfo : public ::google::protobuf::Message {
 public:
  RoomListResponse_RoomInfo();
  virtual ~RoomListResponse_RoomInfo();

  RoomListResponse_RoomInfo(const RoomListResponse_RoomInfo& from);

  inline RoomListResponse_RoomInfo& operator=(const RoomListResponse_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListResponse_RoomInfo& default_instance();

  void Swap(RoomListResponse_RoomInfo* other);

  // implements Message ----------------------------------------------

  RoomListResponse_RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListResponse_RoomInfo& from);
  void MergeFrom(const RoomListResponse_RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::int32 room_id() const;
  inline void set_room_id(::google::protobuf::int32 value);

  // optional string room_name = 2;
  inline bool has_room_name() const;
  inline void clear_room_name();
  static const int kRoomNameFieldNumber = 2;
  inline const ::std::string& room_name() const;
  inline void set_room_name(const ::std::string& value);
  inline void set_room_name(const char* value);
  inline void set_room_name(const char* value, size_t size);
  inline ::std::string* mutable_room_name();
  inline ::std::string* release_room_name();
  inline void set_allocated_room_name(::std::string* room_name);

  // optional int32 max_player = 3;
  inline bool has_max_player() const;
  inline void clear_max_player();
  static const int kMaxPlayerFieldNumber = 3;
  inline ::google::protobuf::int32 max_player() const;
  inline void set_max_player(::google::protobuf::int32 value);

  // optional int32 now_player = 4;
  inline bool has_now_player() const;
  inline void clear_now_player();
  static const int kNowPlayerFieldNumber = 4;
  inline ::google::protobuf::int32 now_player() const;
  inline void set_now_player(::google::protobuf::int32 value);

  // optional .network.ROLE_STRATEGY role_strategy = 5;
  inline bool has_role_strategy() const;
  inline void clear_role_strategy();
  static const int kRoleStrategyFieldNumber = 5;
  inline ::network::ROLE_STRATEGY role_strategy() const;
  inline void set_role_strategy(::network::ROLE_STRATEGY value);

  // optional int32 seat_mode = 6;
  inline bool has_seat_mode() const;
  inline void clear_seat_mode();
  static const int kSeatModeFieldNumber = 6;
  inline ::google::protobuf::int32 seat_mode() const;
  inline void set_seat_mode(::google::protobuf::int32 value);

  // optional int32 role_range = 7;
  inline bool has_role_range() const;
  inline void clear_role_range();
  static const int kRoleRangeFieldNumber = 7;
  inline ::google::protobuf::int32 role_range() const;
  inline void set_role_range(::google::protobuf::int32 value);

  // optional bool allow_guest = 8 [default = true];
  inline bool has_allow_guest() const;
  inline void clear_allow_guest();
  static const int kAllowGuestFieldNumber = 8;
  inline bool allow_guest() const;
  inline void set_allow_guest(bool value);

  // optional bool has_password = 9 [default = false];
  inline bool has_has_password() const;
  inline void clear_has_password();
  static const int kHasPasswordFieldNumber = 9;
  inline bool has_password() const;
  inline void set_has_password(bool value);

  // optional bool first_extension = 10;
  inline bool has_first_extension() const;
  inline void clear_first_extension();
  static const int kFirstExtensionFieldNumber = 10;
  inline bool first_extension() const;
  inline void set_first_extension(bool value);

  // optional bool second_extension = 11;
  inline bool has_second_extension() const;
  inline void clear_second_extension();
  static const int kSecondExtensionFieldNumber = 11;
  inline bool second_extension() const;
  inline void set_second_extension(bool value);

  // optional bool sp_mo_dao = 12;
  inline bool has_sp_mo_dao() const;
  inline void clear_sp_mo_dao();
  static const int kSpMoDaoFieldNumber = 12;
  inline bool sp_mo_dao() const;
  inline void set_sp_mo_dao(bool value);

  // optional bool playing = 13 [default = false];
  inline bool has_playing() const;
  inline void clear_playing();
  static const int kPlayingFieldNumber = 13;
  inline bool playing() const;
  inline void set_playing(bool value);

  // optional bool silence = 14 [default = false];
  inline bool has_silence() const;
  inline void clear_silence();
  static const int kSilenceFieldNumber = 14;
  inline bool silence() const;
  inline void set_silence(bool value);

  // @@protoc_insertion_point(class_scope:network.RoomListResponse.RoomInfo)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_room_name();
  inline void clear_has_room_name();
  inline void set_has_max_player();
  inline void clear_has_max_player();
  inline void set_has_now_player();
  inline void clear_has_now_player();
  inline void set_has_role_strategy();
  inline void clear_has_role_strategy();
  inline void set_has_seat_mode();
  inline void clear_has_seat_mode();
  inline void set_has_role_range();
  inline void clear_has_role_range();
  inline void set_has_allow_guest();
  inline void clear_has_allow_guest();
  inline void set_has_has_password();
  inline void clear_has_has_password();
  inline void set_has_first_extension();
  inline void clear_has_first_extension();
  inline void set_has_second_extension();
  inline void clear_has_second_extension();
  inline void set_has_sp_mo_dao();
  inline void clear_has_sp_mo_dao();
  inline void set_has_playing();
  inline void clear_has_playing();
  inline void set_has_silence();
  inline void clear_has_silence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* room_name_;
  ::google::protobuf::int32 room_id_;
  ::google::protobuf::int32 max_player_;
  ::google::protobuf::int32 now_player_;
  int role_strategy_;
  ::google::protobuf::int32 seat_mode_;
  ::google::protobuf::int32 role_range_;
  bool allow_guest_;
  bool has_password_;
  bool first_extension_;
  bool second_extension_;
  bool sp_mo_dao_;
  bool playing_;
  bool silence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RoomListResponse_RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomListResponse : public ::google::protobuf::Message {
 public:
  RoomListResponse();
  virtual ~RoomListResponse();

  RoomListResponse(const RoomListResponse& from);

  inline RoomListResponse& operator=(const RoomListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListResponse& default_instance();

  void Swap(RoomListResponse* other);

  // implements Message ----------------------------------------------

  RoomListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListResponse& from);
  void MergeFrom(const RoomListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomListResponse_RoomInfo RoomInfo;

  // accessors -------------------------------------------------------

  // repeated .network.RoomListResponse.RoomInfo rooms = 1;
  inline int rooms_size() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 1;
  inline const ::network::RoomListResponse_RoomInfo& rooms(int index) const;
  inline ::network::RoomListResponse_RoomInfo* mutable_rooms(int index);
  inline ::network::RoomListResponse_RoomInfo* add_rooms();
  inline const ::google::protobuf::RepeatedPtrField< ::network::RoomListResponse_RoomInfo >&
      rooms() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::RoomListResponse_RoomInfo >*
      mutable_rooms();

  // @@protoc_insertion_point(class_scope:network.RoomListResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::network::RoomListResponse_RoomInfo > rooms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RoomListResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoomRequest : public ::google::protobuf::Message {
 public:
  CreateRoomRequest();
  virtual ~CreateRoomRequest();

  CreateRoomRequest(const CreateRoomRequest& from);

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomRequest& default_instance();

  void Swap(CreateRoomRequest* other);

  // implements Message ----------------------------------------------

  CreateRoomRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomRequest& from);
  void MergeFrom(const CreateRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string room_name = 1;
  inline bool has_room_name() const;
  inline void clear_room_name();
  static const int kRoomNameFieldNumber = 1;
  inline const ::std::string& room_name() const;
  inline void set_room_name(const ::std::string& value);
  inline void set_room_name(const char* value);
  inline void set_room_name(const char* value, size_t size);
  inline ::std::string* mutable_room_name();
  inline ::std::string* release_room_name();
  inline void set_allocated_room_name(::std::string* room_name);

  // optional int32 max_player = 2;
  inline bool has_max_player() const;
  inline void clear_max_player();
  static const int kMaxPlayerFieldNumber = 2;
  inline ::google::protobuf::int32 max_player() const;
  inline void set_max_player(::google::protobuf::int32 value);

  // optional .network.ROLE_STRATEGY role_strategy = 3;
  inline bool has_role_strategy() const;
  inline void clear_role_strategy();
  static const int kRoleStrategyFieldNumber = 3;
  inline ::network::ROLE_STRATEGY role_strategy() const;
  inline void set_role_strategy(::network::ROLE_STRATEGY value);

  // optional bool first_extension = 4;
  inline bool has_first_extension() const;
  inline void clear_first_extension();
  static const int kFirstExtensionFieldNumber = 4;
  inline bool first_extension() const;
  inline void set_first_extension(bool value);

  // optional bool second_extension = 5;
  inline bool has_second_extension() const;
  inline void clear_second_extension();
  static const int kSecondExtensionFieldNumber = 5;
  inline bool second_extension() const;
  inline void set_second_extension(bool value);

  // optional bool sp_mo_dao = 6;
  inline bool has_sp_mo_dao() const;
  inline void clear_sp_mo_dao();
  static const int kSpMoDaoFieldNumber = 6;
  inline bool sp_mo_dao() const;
  inline void set_sp_mo_dao(bool value);

  // optional int32 seat_mode = 7;
  inline bool has_seat_mode() const;
  inline void clear_seat_mode();
  static const int kSeatModeFieldNumber = 7;
  inline ::google::protobuf::int32 seat_mode() const;
  inline void set_seat_mode(::google::protobuf::int32 value);

  // optional bool allow_guest = 8 [default = true];
  inline bool has_allow_guest() const;
  inline void clear_allow_guest();
  static const int kAllowGuestFieldNumber = 8;
  inline bool allow_guest() const;
  inline void set_allow_guest(bool value);

  // optional string password = 9 [default = ""];
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 9;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool silence = 10 [default = false];
  inline bool has_silence() const;
  inline void clear_silence();
  static const int kSilenceFieldNumber = 10;
  inline bool silence() const;
  inline void set_silence(bool value);

  // @@protoc_insertion_point(class_scope:network.CreateRoomRequest)
 private:
  inline void set_has_room_name();
  inline void clear_has_room_name();
  inline void set_has_max_player();
  inline void clear_has_max_player();
  inline void set_has_role_strategy();
  inline void clear_has_role_strategy();
  inline void set_has_first_extension();
  inline void clear_has_first_extension();
  inline void set_has_second_extension();
  inline void clear_has_second_extension();
  inline void set_has_sp_mo_dao();
  inline void clear_has_sp_mo_dao();
  inline void set_has_seat_mode();
  inline void clear_has_seat_mode();
  inline void set_has_allow_guest();
  inline void clear_has_allow_guest();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_silence();
  inline void clear_has_silence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* room_name_;
  ::google::protobuf::int32 max_player_;
  int role_strategy_;
  bool first_extension_;
  bool second_extension_;
  bool sp_mo_dao_;
  bool allow_guest_;
  ::google::protobuf::int32 seat_mode_;
  ::std::string* password_;
  bool silence_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static CreateRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomRequest : public ::google::protobuf::Message {
 public:
  EnterRoomRequest();
  virtual ~EnterRoomRequest();

  EnterRoomRequest(const EnterRoomRequest& from);

  inline EnterRoomRequest& operator=(const EnterRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomRequest& default_instance();

  void Swap(EnterRoomRequest* other);

  // implements Message ----------------------------------------------

  EnterRoomRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomRequest& from);
  void MergeFrom(const EnterRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::int32 room_id() const;
  inline void set_room_id(::google::protobuf::int32 value);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:network.EnterRoomRequest)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* password_;
  ::google::protobuf::int32 room_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class LeaveRoomRequest : public ::google::protobuf::Message {
 public:
  LeaveRoomRequest();
  virtual ~LeaveRoomRequest();

  LeaveRoomRequest(const LeaveRoomRequest& from);

  inline LeaveRoomRequest& operator=(const LeaveRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveRoomRequest& default_instance();

  void Swap(LeaveRoomRequest* other);

  // implements Message ----------------------------------------------

  LeaveRoomRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveRoomRequest& from);
  void MergeFrom(const LeaveRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:network.LeaveRoomRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LeaveRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class JoinTeamRequest : public ::google::protobuf::Message {
 public:
  JoinTeamRequest();
  virtual ~JoinTeamRequest();

  JoinTeamRequest(const JoinTeamRequest& from);

  inline JoinTeamRequest& operator=(const JoinTeamRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinTeamRequest& default_instance();

  void Swap(JoinTeamRequest* other);

  // implements Message ----------------------------------------------

  JoinTeamRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinTeamRequest& from);
  void MergeFrom(const JoinTeamRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef JoinTeamRequest_Team Team;
  static const Team TEAM_A = JoinTeamRequest_Team_TEAM_A;
  static const Team TEAM_B = JoinTeamRequest_Team_TEAM_B;
  static const Team TEAM_RANDOM = JoinTeamRequest_Team_TEAM_RANDOM;
  static inline bool Team_IsValid(int value) {
    return JoinTeamRequest_Team_IsValid(value);
  }
  static const Team Team_MIN =
    JoinTeamRequest_Team_Team_MIN;
  static const Team Team_MAX =
    JoinTeamRequest_Team_Team_MAX;
  static const int Team_ARRAYSIZE =
    JoinTeamRequest_Team_Team_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Team_descriptor() {
    return JoinTeamRequest_Team_descriptor();
  }
  static inline const ::std::string& Team_Name(Team value) {
    return JoinTeamRequest_Team_Name(value);
  }
  static inline bool Team_Parse(const ::std::string& name,
      Team* value) {
    return JoinTeamRequest_Team_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .network.JoinTeamRequest.Team team = 1;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 1;
  inline ::network::JoinTeamRequest_Team team() const;
  inline void set_team(::network::JoinTeamRequest_Team value);

  // @@protoc_insertion_point(class_scope:network.JoinTeamRequest)
 private:
  inline void set_has_team();
  inline void clear_has_team();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int team_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static JoinTeamRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReadyForGameRequest : public ::google::protobuf::Message {
 public:
  ReadyForGameRequest();
  virtual ~ReadyForGameRequest();

  ReadyForGameRequest(const ReadyForGameRequest& from);

  inline ReadyForGameRequest& operator=(const ReadyForGameRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadyForGameRequest& default_instance();

  void Swap(ReadyForGameRequest* other);

  // implements Message ----------------------------------------------

  ReadyForGameRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadyForGameRequest& from);
  void MergeFrom(const ReadyForGameRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReadyForGameRequest_Type Type;
  static const Type START_READY = ReadyForGameRequest_Type_START_READY;
  static const Type CANCEL_START_REDAY = ReadyForGameRequest_Type_CANCEL_START_REDAY;
  static const Type SEAT_READY = ReadyForGameRequest_Type_SEAT_READY;
  static inline bool Type_IsValid(int value) {
    return ReadyForGameRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ReadyForGameRequest_Type_Type_MIN;
  static const Type Type_MAX =
    ReadyForGameRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ReadyForGameRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ReadyForGameRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ReadyForGameRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ReadyForGameRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .network.ReadyForGameRequest.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::network::ReadyForGameRequest_Type type() const;
  inline void set_type(::network::ReadyForGameRequest_Type value);

  // @@protoc_insertion_point(class_scope:network.ReadyForGameRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static ReadyForGameRequest* default_instance_;
};
// -------------------------------------------------------------------

class SinglePlayerInfo : public ::google::protobuf::Message {
 public:
  SinglePlayerInfo();
  virtual ~SinglePlayerInfo();

  SinglePlayerInfo(const SinglePlayerInfo& from);

  inline SinglePlayerInfo& operator=(const SinglePlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SinglePlayerInfo& default_instance();

  void Swap(SinglePlayerInfo* other);

  // implements Message ----------------------------------------------

  SinglePlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SinglePlayerInfo& from);
  void MergeFrom(const SinglePlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 team = 2;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 2;
  inline ::google::protobuf::uint32 team() const;
  inline void set_team(::google::protobuf::uint32 value);

  // optional uint32 role_id = 3;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 3;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional uint32 hand_count = 4;
  inline bool has_hand_count() const;
  inline void clear_hand_count();
  static const int kHandCountFieldNumber = 4;
  inline ::google::protobuf::uint32 hand_count() const;
  inline void set_hand_count(::google::protobuf::uint32 value);

  // optional uint32 heal_count = 5;
  inline bool has_heal_count() const;
  inline void clear_heal_count();
  static const int kHealCountFieldNumber = 5;
  inline ::google::protobuf::uint32 heal_count() const;
  inline void set_heal_count(::google::protobuf::uint32 value);

  // repeated uint32 ex_cards = 6;
  inline int ex_cards_size() const;
  inline void clear_ex_cards();
  static const int kExCardsFieldNumber = 6;
  inline ::google::protobuf::uint32 ex_cards(int index) const;
  inline void set_ex_cards(int index, ::google::protobuf::uint32 value);
  inline void add_ex_cards(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ex_cards() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ex_cards();

  // repeated uint32 basic_cards = 7;
  inline int basic_cards_size() const;
  inline void clear_basic_cards();
  static const int kBasicCardsFieldNumber = 7;
  inline ::google::protobuf::uint32 basic_cards(int index) const;
  inline void set_basic_cards(int index, ::google::protobuf::uint32 value);
  inline void add_basic_cards(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      basic_cards() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_basic_cards();

  // optional uint32 gem = 8;
  inline bool has_gem() const;
  inline void clear_gem();
  static const int kGemFieldNumber = 8;
  inline ::google::protobuf::uint32 gem() const;
  inline void set_gem(::google::protobuf::uint32 value);

  // optional uint32 crystal = 9;
  inline bool has_crystal() const;
  inline void clear_crystal();
  static const int kCrystalFieldNumber = 9;
  inline ::google::protobuf::uint32 crystal() const;
  inline void set_crystal(::google::protobuf::uint32 value);

  // optional uint32 yellow_token = 10;
  inline bool has_yellow_token() const;
  inline void clear_yellow_token();
  static const int kYellowTokenFieldNumber = 10;
  inline ::google::protobuf::uint32 yellow_token() const;
  inline void set_yellow_token(::google::protobuf::uint32 value);

  // optional uint32 blue_token = 11;
  inline bool has_blue_token() const;
  inline void clear_blue_token();
  static const int kBlueTokenFieldNumber = 11;
  inline ::google::protobuf::uint32 blue_token() const;
  inline void set_blue_token(::google::protobuf::uint32 value);

  // optional uint32 covered_count = 12;
  inline bool has_covered_count() const;
  inline void clear_covered_count();
  static const int kCoveredCountFieldNumber = 12;
  inline ::google::protobuf::uint32 covered_count() const;
  inline void set_covered_count(::google::protobuf::uint32 value);

  // optional bool is_knelt = 13;
  inline bool has_is_knelt() const;
  inline void clear_is_knelt();
  static const int kIsKneltFieldNumber = 13;
  inline bool is_knelt() const;
  inline void set_is_knelt(bool value);

  // repeated uint32 hands = 14;
  inline int hands_size() const;
  inline void clear_hands();
  static const int kHandsFieldNumber = 14;
  inline ::google::protobuf::uint32 hands(int index) const;
  inline void set_hands(int index, ::google::protobuf::uint32 value);
  inline void add_hands(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      hands() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_hands();

  // repeated uint32 covereds = 15;
  inline int covereds_size() const;
  inline void clear_covereds();
  static const int kCoveredsFieldNumber = 15;
  inline ::google::protobuf::uint32 covereds(int index) const;
  inline void set_covereds(int index, ::google::protobuf::uint32 value);
  inline void add_covereds(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      covereds() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_covereds();

  // optional uint32 max_hand = 16;
  inline bool has_max_hand() const;
  inline void clear_max_hand();
  static const int kMaxHandFieldNumber = 16;
  inline ::google::protobuf::uint32 max_hand() const;
  inline void set_max_hand(::google::protobuf::uint32 value);

  // optional string nickname = 17;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 17;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional bool ready = 18 [default = false];
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 18;
  inline bool ready() const;
  inline void set_ready(bool value);

  // repeated string delete_field = 19;
  inline int delete_field_size() const;
  inline void clear_delete_field();
  static const int kDeleteFieldFieldNumber = 19;
  inline const ::std::string& delete_field(int index) const;
  inline ::std::string* mutable_delete_field(int index);
  inline void set_delete_field(int index, const ::std::string& value);
  inline void set_delete_field(int index, const char* value);
  inline void set_delete_field(int index, const char* value, size_t size);
  inline ::std::string* add_delete_field();
  inline void add_delete_field(const ::std::string& value);
  inline void add_delete_field(const char* value);
  inline void add_delete_field(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& delete_field() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_delete_field();

  // @@protoc_insertion_point(class_scope:network.SinglePlayerInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_hand_count();
  inline void clear_has_hand_count();
  inline void set_has_heal_count();
  inline void clear_has_heal_count();
  inline void set_has_gem();
  inline void clear_has_gem();
  inline void set_has_crystal();
  inline void clear_has_crystal();
  inline void set_has_yellow_token();
  inline void clear_has_yellow_token();
  inline void set_has_blue_token();
  inline void clear_has_blue_token();
  inline void set_has_covered_count();
  inline void clear_has_covered_count();
  inline void set_has_is_knelt();
  inline void clear_has_is_knelt();
  inline void set_has_max_hand();
  inline void clear_has_max_hand();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_ready();
  inline void clear_has_ready();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 team_;
  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 hand_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ex_cards_;
  ::google::protobuf::uint32 heal_count_;
  ::google::protobuf::uint32 gem_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > basic_cards_;
  ::google::protobuf::uint32 crystal_;
  ::google::protobuf::uint32 yellow_token_;
  ::google::protobuf::uint32 blue_token_;
  ::google::protobuf::uint32 covered_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > hands_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > covereds_;
  bool is_knelt_;
  bool ready_;
  ::google::protobuf::uint32 max_hand_;
  ::std::string* nickname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> delete_field_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static SinglePlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  void Swap(GameInfo* other);

  // implements Message ----------------------------------------------

  GameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::int32 room_id() const;
  inline void set_room_id(::google::protobuf::int32 value);

  // optional int32 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int32 player_id() const;
  inline void set_player_id(::google::protobuf::int32 value);

  // optional uint32 red_morale = 3;
  inline bool has_red_morale() const;
  inline void clear_red_morale();
  static const int kRedMoraleFieldNumber = 3;
  inline ::google::protobuf::uint32 red_morale() const;
  inline void set_red_morale(::google::protobuf::uint32 value);

  // optional uint32 blue_morale = 4;
  inline bool has_blue_morale() const;
  inline void clear_blue_morale();
  static const int kBlueMoraleFieldNumber = 4;
  inline ::google::protobuf::uint32 blue_morale() const;
  inline void set_blue_morale(::google::protobuf::uint32 value);

  // optional uint32 red_gem = 5;
  inline bool has_red_gem() const;
  inline void clear_red_gem();
  static const int kRedGemFieldNumber = 5;
  inline ::google::protobuf::uint32 red_gem() const;
  inline void set_red_gem(::google::protobuf::uint32 value);

  // optional uint32 blue_gem = 6;
  inline bool has_blue_gem() const;
  inline void clear_blue_gem();
  static const int kBlueGemFieldNumber = 6;
  inline ::google::protobuf::uint32 blue_gem() const;
  inline void set_blue_gem(::google::protobuf::uint32 value);

  // optional uint32 red_crystal = 7;
  inline bool has_red_crystal() const;
  inline void clear_red_crystal();
  static const int kRedCrystalFieldNumber = 7;
  inline ::google::protobuf::uint32 red_crystal() const;
  inline void set_red_crystal(::google::protobuf::uint32 value);

  // optional uint32 blue_crystal = 8;
  inline bool has_blue_crystal() const;
  inline void clear_blue_crystal();
  static const int kBlueCrystalFieldNumber = 8;
  inline ::google::protobuf::uint32 blue_crystal() const;
  inline void set_blue_crystal(::google::protobuf::uint32 value);

  // optional uint32 red_grail = 9;
  inline bool has_red_grail() const;
  inline void clear_red_grail();
  static const int kRedGrailFieldNumber = 9;
  inline ::google::protobuf::uint32 red_grail() const;
  inline void set_red_grail(::google::protobuf::uint32 value);

  // optional uint32 blue_grail = 10;
  inline bool has_blue_grail() const;
  inline void clear_blue_grail();
  static const int kBlueGrailFieldNumber = 10;
  inline ::google::protobuf::uint32 blue_grail() const;
  inline void set_blue_grail(::google::protobuf::uint32 value);

  // optional uint32 pile = 11;
  inline bool has_pile() const;
  inline void clear_pile();
  static const int kPileFieldNumber = 11;
  inline ::google::protobuf::uint32 pile() const;
  inline void set_pile(::google::protobuf::uint32 value);

  // optional uint32 discard = 12;
  inline bool has_discard() const;
  inline void clear_discard();
  static const int kDiscardFieldNumber = 12;
  inline ::google::protobuf::uint32 discard() const;
  inline void set_discard(::google::protobuf::uint32 value);

  // optional bool is_started = 13 [default = false];
  inline bool has_is_started() const;
  inline void clear_is_started();
  static const int kIsStartedFieldNumber = 13;
  inline bool is_started() const;
  inline void set_is_started(bool value);

  // repeated .network.SinglePlayerInfo player_infos = 14;
  inline int player_infos_size() const;
  inline void clear_player_infos();
  static const int kPlayerInfosFieldNumber = 14;
  inline const ::network::SinglePlayerInfo& player_infos(int index) const;
  inline ::network::SinglePlayerInfo* mutable_player_infos(int index);
  inline ::network::SinglePlayerInfo* add_player_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >&
      player_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >*
      mutable_player_infos();

  // @@protoc_insertion_point(class_scope:network.GameInfo)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_red_morale();
  inline void clear_has_red_morale();
  inline void set_has_blue_morale();
  inline void clear_has_blue_morale();
  inline void set_has_red_gem();
  inline void clear_has_red_gem();
  inline void set_has_blue_gem();
  inline void clear_has_blue_gem();
  inline void set_has_red_crystal();
  inline void clear_has_red_crystal();
  inline void set_has_blue_crystal();
  inline void clear_has_blue_crystal();
  inline void set_has_red_grail();
  inline void clear_has_red_grail();
  inline void set_has_blue_grail();
  inline void clear_has_blue_grail();
  inline void set_has_pile();
  inline void clear_has_pile();
  inline void set_has_discard();
  inline void clear_has_discard();
  inline void set_has_is_started();
  inline void clear_has_is_started();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 room_id_;
  ::google::protobuf::int32 player_id_;
  ::google::protobuf::uint32 red_morale_;
  ::google::protobuf::uint32 blue_morale_;
  ::google::protobuf::uint32 red_gem_;
  ::google::protobuf::uint32 blue_gem_;
  ::google::protobuf::uint32 red_crystal_;
  ::google::protobuf::uint32 blue_crystal_;
  ::google::protobuf::uint32 red_grail_;
  ::google::protobuf::uint32 blue_grail_;
  ::google::protobuf::uint32 pile_;
  ::google::protobuf::uint32 discard_;
  ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo > player_infos_;
  bool is_started_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class Talk : public ::google::protobuf::Message {
 public:
  Talk();
  virtual ~Talk();

  Talk(const Talk& from);

  inline Talk& operator=(const Talk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Talk& default_instance();

  void Swap(Talk* other);

  // implements Message ----------------------------------------------

  Talk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Talk& from);
  void MergeFrom(const Talk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string txt = 1;
  inline bool has_txt() const;
  inline void clear_txt();
  static const int kTxtFieldNumber = 1;
  inline const ::std::string& txt() const;
  inline void set_txt(const ::std::string& value);
  inline void set_txt(const char* value);
  inline void set_txt(const char* value, size_t size);
  inline ::std::string* mutable_txt();
  inline ::std::string* release_txt();
  inline void set_allocated_txt(::std::string* txt);

  // @@protoc_insertion_point(class_scope:network.Talk)
 private:
  inline void set_has_txt();
  inline void clear_has_txt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static Talk* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  void Swap(Error* other);

  // implements Message ----------------------------------------------

  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 dst_id = 2;
  inline bool has_dst_id() const;
  inline void clear_dst_id();
  static const int kDstIdFieldNumber = 2;
  inline ::google::protobuf::int32 dst_id() const;
  inline void set_dst_id(::google::protobuf::int32 value);

  // repeated int32 args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline ::google::protobuf::int32 args(int index) const;
  inline void set_args(int index, ::google::protobuf::int32 value);
  inline void add_args(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      args() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_args();

  // @@protoc_insertion_point(class_scope:network.Error)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_dst_id();
  inline void clear_has_dst_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 dst_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class Gossip : public ::google::protobuf::Message {
 public:
  Gossip();
  virtual ~Gossip();

  Gossip(const Gossip& from);

  inline Gossip& operator=(const Gossip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gossip& default_instance();

  void Swap(Gossip* other);

  // implements Message ----------------------------------------------

  Gossip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Gossip& from);
  void MergeFrom(const Gossip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .network.GossipType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::network::GossipType type() const;
  inline void set_type(::network::GossipType value);

  // optional string txt = 2;
  inline bool has_txt() const;
  inline void clear_txt();
  static const int kTxtFieldNumber = 2;
  inline const ::std::string& txt() const;
  inline void set_txt(const ::std::string& value);
  inline void set_txt(const char* value);
  inline void set_txt(const char* value, size_t size);
  inline ::std::string* mutable_txt();
  inline ::std::string* release_txt();
  inline void set_allocated_txt(::std::string* txt);

  // optional uint32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:network.Gossip)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_txt();
  inline void clear_has_txt();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txt_;
  int type_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static Gossip* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeat : public ::google::protobuf::Message {
 public:
  HeartBeat();
  virtual ~HeartBeat();

  HeartBeat(const HeartBeat& from);

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeat& default_instance();

  void Swap(HeartBeat* other);

  // implements Message ----------------------------------------------

  HeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:network.HeartBeat)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static HeartBeat* default_instance_;
};
// ===================================================================


// ===================================================================

// RegisterRequest

// optional string user_id = 1;
inline bool RegisterRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRequest::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& RegisterRequest::user_id() const {
  return *user_id_;
}
inline void RegisterRequest::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void RegisterRequest::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void RegisterRequest::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* RegisterRequest::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_password = 2;
inline bool RegisterRequest::has_user_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRequest::set_has_user_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRequest::clear_has_user_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRequest::clear_user_password() {
  if (user_password_ != &::google::protobuf::internal::kEmptyString) {
    user_password_->clear();
  }
  clear_has_user_password();
}
inline const ::std::string& RegisterRequest::user_password() const {
  return *user_password_;
}
inline void RegisterRequest::set_user_password(const ::std::string& value) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(value);
}
inline void RegisterRequest::set_user_password(const char* value) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(value);
}
inline void RegisterRequest::set_user_password(const char* value, size_t size) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_user_password() {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  return user_password_;
}
inline ::std::string* RegisterRequest::release_user_password() {
  clear_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_password_;
    user_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_user_password(::std::string* user_password) {
  if (user_password_ != &::google::protobuf::internal::kEmptyString) {
    delete user_password_;
  }
  if (user_password) {
    set_has_user_password();
    user_password_ = user_password;
  } else {
    clear_has_user_password();
    user_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickname = 3;
inline bool RegisterRequest::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterRequest::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterRequest::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterRequest::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& RegisterRequest::nickname() const {
  return *nickname_;
}
inline void RegisterRequest::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RegisterRequest::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RegisterRequest::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* RegisterRequest::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile = 4;
inline bool RegisterRequest::has_mobile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterRequest::set_has_mobile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterRequest::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterRequest::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& RegisterRequest::mobile() const {
  return *mobile_;
}
inline void RegisterRequest::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void RegisterRequest::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void RegisterRequest::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* RegisterRequest::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 5;
inline bool RegisterRequest::has_email() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterRequest::set_has_email() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterRequest::clear_has_email() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterRequest::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& RegisterRequest::email() const {
  return *email_;
}
inline void RegisterRequest::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void RegisterRequest::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void RegisterRequest::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* RegisterRequest::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterResponse

// optional uint32 state = 1;
inline bool RegisterResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterResponse::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 RegisterResponse::state() const {
  return state_;
}
inline void RegisterResponse::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// LoginRequest

// required bool asGuest = 1;
inline bool LoginRequest::has_asguest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_asguest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_asguest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_asguest() {
  asguest_ = false;
  clear_has_asguest();
}
inline bool LoginRequest::asguest() const {
  return asguest_;
}
inline void LoginRequest::set_asguest(bool value) {
  set_has_asguest();
  asguest_ = value;
}

// optional string user_id = 2;
inline bool LoginRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& LoginRequest::user_id() const {
  return *user_id_;
}
inline void LoginRequest::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void LoginRequest::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void LoginRequest::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* LoginRequest::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_password = 3;
inline bool LoginRequest::has_user_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_user_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_user_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_user_password() {
  if (user_password_ != &::google::protobuf::internal::kEmptyString) {
    user_password_->clear();
  }
  clear_has_user_password();
}
inline const ::std::string& LoginRequest::user_password() const {
  return *user_password_;
}
inline void LoginRequest::set_user_password(const ::std::string& value) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(value);
}
inline void LoginRequest::set_user_password(const char* value) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(value);
}
inline void LoginRequest::set_user_password(const char* value, size_t size) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_user_password() {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  return user_password_;
}
inline ::std::string* LoginRequest::release_user_password() {
  clear_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_password_;
    user_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_user_password(::std::string* user_password) {
  if (user_password_ != &::google::protobuf::internal::kEmptyString) {
    delete user_password_;
  }
  if (user_password) {
    set_has_user_password();
    user_password_ = user_password;
  } else {
    clear_has_user_password();
    user_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 version = 4 [default = -1];
inline bool LoginRequest::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_version() {
  version_ = -1;
  clear_has_version();
}
inline ::google::protobuf::int32 LoginRequest::version() const {
  return version_;
}
inline void LoginRequest::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// LoginResponse

// required int32 state = 1;
inline bool LoginResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 LoginResponse::state() const {
  return state_;
}
inline void LoginResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional string nickname = 2;
inline bool LoginResponse::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& LoginResponse::nickname() const {
  return *nickname_;
}
inline void LoginResponse::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void LoginResponse::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void LoginResponse::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* LoginResponse::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogoutRequest

// -------------------------------------------------------------------

// LogoutResponse

// repeated uint32 args = 1;
inline int LogoutResponse::args_size() const {
  return args_.size();
}
inline void LogoutResponse::clear_args() {
  args_.Clear();
}
inline ::google::protobuf::uint32 LogoutResponse::args(int index) const {
  return args_.Get(index);
}
inline void LogoutResponse::set_args(int index, ::google::protobuf::uint32 value) {
  args_.Set(index, value);
}
inline void LogoutResponse::add_args(::google::protobuf::uint32 value) {
  args_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
LogoutResponse::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
LogoutResponse::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// RoomListRequest

// required .network.ROLE_STRATEGY role_strategy = 1;
inline bool RoomListRequest::has_role_strategy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomListRequest::set_has_role_strategy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomListRequest::clear_has_role_strategy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomListRequest::clear_role_strategy() {
  role_strategy_ = 1;
  clear_has_role_strategy();
}
inline ::network::ROLE_STRATEGY RoomListRequest::role_strategy() const {
  return static_cast< ::network::ROLE_STRATEGY >(role_strategy_);
}
inline void RoomListRequest::set_role_strategy(::network::ROLE_STRATEGY value) {
  assert(::network::ROLE_STRATEGY_IsValid(value));
  set_has_role_strategy();
  role_strategy_ = value;
}

// -------------------------------------------------------------------

// RoomListResponse_RoomInfo

// optional int32 room_id = 1;
inline bool RoomListResponse_RoomInfo::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomListResponse_RoomInfo::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomListResponse_RoomInfo::clear_room_id() {
  room_id_ = 0;
  clear_has_room_id();
}
inline ::google::protobuf::int32 RoomListResponse_RoomInfo::room_id() const {
  return room_id_;
}
inline void RoomListResponse_RoomInfo::set_room_id(::google::protobuf::int32 value) {
  set_has_room_id();
  room_id_ = value;
}

// optional string room_name = 2;
inline bool RoomListResponse_RoomInfo::has_room_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_room_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomListResponse_RoomInfo::clear_has_room_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomListResponse_RoomInfo::clear_room_name() {
  if (room_name_ != &::google::protobuf::internal::kEmptyString) {
    room_name_->clear();
  }
  clear_has_room_name();
}
inline const ::std::string& RoomListResponse_RoomInfo::room_name() const {
  return *room_name_;
}
inline void RoomListResponse_RoomInfo::set_room_name(const ::std::string& value) {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  room_name_->assign(value);
}
inline void RoomListResponse_RoomInfo::set_room_name(const char* value) {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  room_name_->assign(value);
}
inline void RoomListResponse_RoomInfo::set_room_name(const char* value, size_t size) {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  room_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomListResponse_RoomInfo::mutable_room_name() {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  return room_name_;
}
inline ::std::string* RoomListResponse_RoomInfo::release_room_name() {
  clear_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_name_;
    room_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomListResponse_RoomInfo::set_allocated_room_name(::std::string* room_name) {
  if (room_name_ != &::google::protobuf::internal::kEmptyString) {
    delete room_name_;
  }
  if (room_name) {
    set_has_room_name();
    room_name_ = room_name;
  } else {
    clear_has_room_name();
    room_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 max_player = 3;
inline bool RoomListResponse_RoomInfo::has_max_player() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_max_player() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomListResponse_RoomInfo::clear_has_max_player() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomListResponse_RoomInfo::clear_max_player() {
  max_player_ = 0;
  clear_has_max_player();
}
inline ::google::protobuf::int32 RoomListResponse_RoomInfo::max_player() const {
  return max_player_;
}
inline void RoomListResponse_RoomInfo::set_max_player(::google::protobuf::int32 value) {
  set_has_max_player();
  max_player_ = value;
}

// optional int32 now_player = 4;
inline bool RoomListResponse_RoomInfo::has_now_player() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_now_player() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomListResponse_RoomInfo::clear_has_now_player() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomListResponse_RoomInfo::clear_now_player() {
  now_player_ = 0;
  clear_has_now_player();
}
inline ::google::protobuf::int32 RoomListResponse_RoomInfo::now_player() const {
  return now_player_;
}
inline void RoomListResponse_RoomInfo::set_now_player(::google::protobuf::int32 value) {
  set_has_now_player();
  now_player_ = value;
}

// optional .network.ROLE_STRATEGY role_strategy = 5;
inline bool RoomListResponse_RoomInfo::has_role_strategy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_role_strategy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomListResponse_RoomInfo::clear_has_role_strategy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomListResponse_RoomInfo::clear_role_strategy() {
  role_strategy_ = 1;
  clear_has_role_strategy();
}
inline ::network::ROLE_STRATEGY RoomListResponse_RoomInfo::role_strategy() const {
  return static_cast< ::network::ROLE_STRATEGY >(role_strategy_);
}
inline void RoomListResponse_RoomInfo::set_role_strategy(::network::ROLE_STRATEGY value) {
  assert(::network::ROLE_STRATEGY_IsValid(value));
  set_has_role_strategy();
  role_strategy_ = value;
}

// optional int32 seat_mode = 6;
inline bool RoomListResponse_RoomInfo::has_seat_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_seat_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomListResponse_RoomInfo::clear_has_seat_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomListResponse_RoomInfo::clear_seat_mode() {
  seat_mode_ = 0;
  clear_has_seat_mode();
}
inline ::google::protobuf::int32 RoomListResponse_RoomInfo::seat_mode() const {
  return seat_mode_;
}
inline void RoomListResponse_RoomInfo::set_seat_mode(::google::protobuf::int32 value) {
  set_has_seat_mode();
  seat_mode_ = value;
}

// optional int32 role_range = 7;
inline bool RoomListResponse_RoomInfo::has_role_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_role_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomListResponse_RoomInfo::clear_has_role_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomListResponse_RoomInfo::clear_role_range() {
  role_range_ = 0;
  clear_has_role_range();
}
inline ::google::protobuf::int32 RoomListResponse_RoomInfo::role_range() const {
  return role_range_;
}
inline void RoomListResponse_RoomInfo::set_role_range(::google::protobuf::int32 value) {
  set_has_role_range();
  role_range_ = value;
}

// optional bool allow_guest = 8 [default = true];
inline bool RoomListResponse_RoomInfo::has_allow_guest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_allow_guest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomListResponse_RoomInfo::clear_has_allow_guest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomListResponse_RoomInfo::clear_allow_guest() {
  allow_guest_ = true;
  clear_has_allow_guest();
}
inline bool RoomListResponse_RoomInfo::allow_guest() const {
  return allow_guest_;
}
inline void RoomListResponse_RoomInfo::set_allow_guest(bool value) {
  set_has_allow_guest();
  allow_guest_ = value;
}

// optional bool has_password = 9 [default = false];
inline bool RoomListResponse_RoomInfo::has_has_password() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_has_password() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomListResponse_RoomInfo::clear_has_has_password() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomListResponse_RoomInfo::clear_has_password() {
  has_password_ = false;
  clear_has_has_password();
}
inline bool RoomListResponse_RoomInfo::has_password() const {
  return has_password_;
}
inline void RoomListResponse_RoomInfo::set_has_password(bool value) {
  set_has_has_password();
  has_password_ = value;
}

// optional bool first_extension = 10;
inline bool RoomListResponse_RoomInfo::has_first_extension() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_first_extension() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RoomListResponse_RoomInfo::clear_has_first_extension() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RoomListResponse_RoomInfo::clear_first_extension() {
  first_extension_ = false;
  clear_has_first_extension();
}
inline bool RoomListResponse_RoomInfo::first_extension() const {
  return first_extension_;
}
inline void RoomListResponse_RoomInfo::set_first_extension(bool value) {
  set_has_first_extension();
  first_extension_ = value;
}

// optional bool second_extension = 11;
inline bool RoomListResponse_RoomInfo::has_second_extension() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_second_extension() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RoomListResponse_RoomInfo::clear_has_second_extension() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RoomListResponse_RoomInfo::clear_second_extension() {
  second_extension_ = false;
  clear_has_second_extension();
}
inline bool RoomListResponse_RoomInfo::second_extension() const {
  return second_extension_;
}
inline void RoomListResponse_RoomInfo::set_second_extension(bool value) {
  set_has_second_extension();
  second_extension_ = value;
}

// optional bool sp_mo_dao = 12;
inline bool RoomListResponse_RoomInfo::has_sp_mo_dao() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_sp_mo_dao() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RoomListResponse_RoomInfo::clear_has_sp_mo_dao() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RoomListResponse_RoomInfo::clear_sp_mo_dao() {
  sp_mo_dao_ = false;
  clear_has_sp_mo_dao();
}
inline bool RoomListResponse_RoomInfo::sp_mo_dao() const {
  return sp_mo_dao_;
}
inline void RoomListResponse_RoomInfo::set_sp_mo_dao(bool value) {
  set_has_sp_mo_dao();
  sp_mo_dao_ = value;
}

// optional bool playing = 13 [default = false];
inline bool RoomListResponse_RoomInfo::has_playing() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_playing() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RoomListResponse_RoomInfo::clear_has_playing() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RoomListResponse_RoomInfo::clear_playing() {
  playing_ = false;
  clear_has_playing();
}
inline bool RoomListResponse_RoomInfo::playing() const {
  return playing_;
}
inline void RoomListResponse_RoomInfo::set_playing(bool value) {
  set_has_playing();
  playing_ = value;
}

// optional bool silence = 14 [default = false];
inline bool RoomListResponse_RoomInfo::has_silence() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_silence() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RoomListResponse_RoomInfo::clear_has_silence() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RoomListResponse_RoomInfo::clear_silence() {
  silence_ = false;
  clear_has_silence();
}
inline bool RoomListResponse_RoomInfo::silence() const {
  return silence_;
}
inline void RoomListResponse_RoomInfo::set_silence(bool value) {
  set_has_silence();
  silence_ = value;
}

// -------------------------------------------------------------------

// RoomListResponse

// repeated .network.RoomListResponse.RoomInfo rooms = 1;
inline int RoomListResponse::rooms_size() const {
  return rooms_.size();
}
inline void RoomListResponse::clear_rooms() {
  rooms_.Clear();
}
inline const ::network::RoomListResponse_RoomInfo& RoomListResponse::rooms(int index) const {
  return rooms_.Get(index);
}
inline ::network::RoomListResponse_RoomInfo* RoomListResponse::mutable_rooms(int index) {
  return rooms_.Mutable(index);
}
inline ::network::RoomListResponse_RoomInfo* RoomListResponse::add_rooms() {
  return rooms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::RoomListResponse_RoomInfo >&
RoomListResponse::rooms() const {
  return rooms_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::RoomListResponse_RoomInfo >*
RoomListResponse::mutable_rooms() {
  return &rooms_;
}

// -------------------------------------------------------------------

// CreateRoomRequest

// optional string room_name = 1;
inline bool CreateRoomRequest::has_room_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomRequest::set_has_room_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomRequest::clear_has_room_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomRequest::clear_room_name() {
  if (room_name_ != &::google::protobuf::internal::kEmptyString) {
    room_name_->clear();
  }
  clear_has_room_name();
}
inline const ::std::string& CreateRoomRequest::room_name() const {
  return *room_name_;
}
inline void CreateRoomRequest::set_room_name(const ::std::string& value) {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  room_name_->assign(value);
}
inline void CreateRoomRequest::set_room_name(const char* value) {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  room_name_->assign(value);
}
inline void CreateRoomRequest::set_room_name(const char* value, size_t size) {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  room_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoomRequest::mutable_room_name() {
  set_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    room_name_ = new ::std::string;
  }
  return room_name_;
}
inline ::std::string* CreateRoomRequest::release_room_name() {
  clear_has_room_name();
  if (room_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_name_;
    room_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoomRequest::set_allocated_room_name(::std::string* room_name) {
  if (room_name_ != &::google::protobuf::internal::kEmptyString) {
    delete room_name_;
  }
  if (room_name) {
    set_has_room_name();
    room_name_ = room_name;
  } else {
    clear_has_room_name();
    room_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 max_player = 2;
inline bool CreateRoomRequest::has_max_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomRequest::set_has_max_player() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomRequest::clear_has_max_player() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomRequest::clear_max_player() {
  max_player_ = 0;
  clear_has_max_player();
}
inline ::google::protobuf::int32 CreateRoomRequest::max_player() const {
  return max_player_;
}
inline void CreateRoomRequest::set_max_player(::google::protobuf::int32 value) {
  set_has_max_player();
  max_player_ = value;
}

// optional .network.ROLE_STRATEGY role_strategy = 3;
inline bool CreateRoomRequest::has_role_strategy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoomRequest::set_has_role_strategy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoomRequest::clear_has_role_strategy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoomRequest::clear_role_strategy() {
  role_strategy_ = 1;
  clear_has_role_strategy();
}
inline ::network::ROLE_STRATEGY CreateRoomRequest::role_strategy() const {
  return static_cast< ::network::ROLE_STRATEGY >(role_strategy_);
}
inline void CreateRoomRequest::set_role_strategy(::network::ROLE_STRATEGY value) {
  assert(::network::ROLE_STRATEGY_IsValid(value));
  set_has_role_strategy();
  role_strategy_ = value;
}

// optional bool first_extension = 4;
inline bool CreateRoomRequest::has_first_extension() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateRoomRequest::set_has_first_extension() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateRoomRequest::clear_has_first_extension() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateRoomRequest::clear_first_extension() {
  first_extension_ = false;
  clear_has_first_extension();
}
inline bool CreateRoomRequest::first_extension() const {
  return first_extension_;
}
inline void CreateRoomRequest::set_first_extension(bool value) {
  set_has_first_extension();
  first_extension_ = value;
}

// optional bool second_extension = 5;
inline bool CreateRoomRequest::has_second_extension() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateRoomRequest::set_has_second_extension() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateRoomRequest::clear_has_second_extension() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateRoomRequest::clear_second_extension() {
  second_extension_ = false;
  clear_has_second_extension();
}
inline bool CreateRoomRequest::second_extension() const {
  return second_extension_;
}
inline void CreateRoomRequest::set_second_extension(bool value) {
  set_has_second_extension();
  second_extension_ = value;
}

// optional bool sp_mo_dao = 6;
inline bool CreateRoomRequest::has_sp_mo_dao() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateRoomRequest::set_has_sp_mo_dao() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateRoomRequest::clear_has_sp_mo_dao() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateRoomRequest::clear_sp_mo_dao() {
  sp_mo_dao_ = false;
  clear_has_sp_mo_dao();
}
inline bool CreateRoomRequest::sp_mo_dao() const {
  return sp_mo_dao_;
}
inline void CreateRoomRequest::set_sp_mo_dao(bool value) {
  set_has_sp_mo_dao();
  sp_mo_dao_ = value;
}

// optional int32 seat_mode = 7;
inline bool CreateRoomRequest::has_seat_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateRoomRequest::set_has_seat_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateRoomRequest::clear_has_seat_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateRoomRequest::clear_seat_mode() {
  seat_mode_ = 0;
  clear_has_seat_mode();
}
inline ::google::protobuf::int32 CreateRoomRequest::seat_mode() const {
  return seat_mode_;
}
inline void CreateRoomRequest::set_seat_mode(::google::protobuf::int32 value) {
  set_has_seat_mode();
  seat_mode_ = value;
}

// optional bool allow_guest = 8 [default = true];
inline bool CreateRoomRequest::has_allow_guest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateRoomRequest::set_has_allow_guest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateRoomRequest::clear_has_allow_guest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateRoomRequest::clear_allow_guest() {
  allow_guest_ = true;
  clear_has_allow_guest();
}
inline bool CreateRoomRequest::allow_guest() const {
  return allow_guest_;
}
inline void CreateRoomRequest::set_allow_guest(bool value) {
  set_has_allow_guest();
  allow_guest_ = value;
}

// optional string password = 9 [default = ""];
inline bool CreateRoomRequest::has_password() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CreateRoomRequest::set_has_password() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CreateRoomRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CreateRoomRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CreateRoomRequest::password() const {
  return *password_;
}
inline void CreateRoomRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CreateRoomRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CreateRoomRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoomRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CreateRoomRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoomRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool silence = 10 [default = false];
inline bool CreateRoomRequest::has_silence() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CreateRoomRequest::set_has_silence() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CreateRoomRequest::clear_has_silence() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CreateRoomRequest::clear_silence() {
  silence_ = false;
  clear_has_silence();
}
inline bool CreateRoomRequest::silence() const {
  return silence_;
}
inline void CreateRoomRequest::set_silence(bool value) {
  set_has_silence();
  silence_ = value;
}

// -------------------------------------------------------------------

// EnterRoomRequest

// required int32 room_id = 1;
inline bool EnterRoomRequest::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomRequest::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomRequest::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomRequest::clear_room_id() {
  room_id_ = 0;
  clear_has_room_id();
}
inline ::google::protobuf::int32 EnterRoomRequest::room_id() const {
  return room_id_;
}
inline void EnterRoomRequest::set_room_id(::google::protobuf::int32 value) {
  set_has_room_id();
  room_id_ = value;
}

// optional string password = 2;
inline bool EnterRoomRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& EnterRoomRequest::password() const {
  return *password_;
}
inline void EnterRoomRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void EnterRoomRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void EnterRoomRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoomRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* EnterRoomRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterRoomRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LeaveRoomRequest

// -------------------------------------------------------------------

// JoinTeamRequest

// required .network.JoinTeamRequest.Team team = 1;
inline bool JoinTeamRequest::has_team() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinTeamRequest::set_has_team() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinTeamRequest::clear_has_team() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinTeamRequest::clear_team() {
  team_ = 1;
  clear_has_team();
}
inline ::network::JoinTeamRequest_Team JoinTeamRequest::team() const {
  return static_cast< ::network::JoinTeamRequest_Team >(team_);
}
inline void JoinTeamRequest::set_team(::network::JoinTeamRequest_Team value) {
  assert(::network::JoinTeamRequest_Team_IsValid(value));
  set_has_team();
  team_ = value;
}

// -------------------------------------------------------------------

// ReadyForGameRequest

// required .network.ReadyForGameRequest.Type type = 1;
inline bool ReadyForGameRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadyForGameRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadyForGameRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadyForGameRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::network::ReadyForGameRequest_Type ReadyForGameRequest::type() const {
  return static_cast< ::network::ReadyForGameRequest_Type >(type_);
}
inline void ReadyForGameRequest::set_type(::network::ReadyForGameRequest_Type value) {
  assert(::network::ReadyForGameRequest_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// SinglePlayerInfo

// optional uint32 id = 1;
inline bool SinglePlayerInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SinglePlayerInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SinglePlayerInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SinglePlayerInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::id() const {
  return id_;
}
inline void SinglePlayerInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 team = 2;
inline bool SinglePlayerInfo::has_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SinglePlayerInfo::set_has_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SinglePlayerInfo::clear_has_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SinglePlayerInfo::clear_team() {
  team_ = 0u;
  clear_has_team();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::team() const {
  return team_;
}
inline void SinglePlayerInfo::set_team(::google::protobuf::uint32 value) {
  set_has_team();
  team_ = value;
}

// optional uint32 role_id = 3;
inline bool SinglePlayerInfo::has_role_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SinglePlayerInfo::set_has_role_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SinglePlayerInfo::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SinglePlayerInfo::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::role_id() const {
  return role_id_;
}
inline void SinglePlayerInfo::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional uint32 hand_count = 4;
inline bool SinglePlayerInfo::has_hand_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SinglePlayerInfo::set_has_hand_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SinglePlayerInfo::clear_has_hand_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SinglePlayerInfo::clear_hand_count() {
  hand_count_ = 0u;
  clear_has_hand_count();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::hand_count() const {
  return hand_count_;
}
inline void SinglePlayerInfo::set_hand_count(::google::protobuf::uint32 value) {
  set_has_hand_count();
  hand_count_ = value;
}

// optional uint32 heal_count = 5;
inline bool SinglePlayerInfo::has_heal_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SinglePlayerInfo::set_has_heal_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SinglePlayerInfo::clear_has_heal_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SinglePlayerInfo::clear_heal_count() {
  heal_count_ = 0u;
  clear_has_heal_count();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::heal_count() const {
  return heal_count_;
}
inline void SinglePlayerInfo::set_heal_count(::google::protobuf::uint32 value) {
  set_has_heal_count();
  heal_count_ = value;
}

// repeated uint32 ex_cards = 6;
inline int SinglePlayerInfo::ex_cards_size() const {
  return ex_cards_.size();
}
inline void SinglePlayerInfo::clear_ex_cards() {
  ex_cards_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::ex_cards(int index) const {
  return ex_cards_.Get(index);
}
inline void SinglePlayerInfo::set_ex_cards(int index, ::google::protobuf::uint32 value) {
  ex_cards_.Set(index, value);
}
inline void SinglePlayerInfo::add_ex_cards(::google::protobuf::uint32 value) {
  ex_cards_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::ex_cards() const {
  return ex_cards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_ex_cards() {
  return &ex_cards_;
}

// repeated uint32 basic_cards = 7;
inline int SinglePlayerInfo::basic_cards_size() const {
  return basic_cards_.size();
}
inline void SinglePlayerInfo::clear_basic_cards() {
  basic_cards_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::basic_cards(int index) const {
  return basic_cards_.Get(index);
}
inline void SinglePlayerInfo::set_basic_cards(int index, ::google::protobuf::uint32 value) {
  basic_cards_.Set(index, value);
}
inline void SinglePlayerInfo::add_basic_cards(::google::protobuf::uint32 value) {
  basic_cards_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::basic_cards() const {
  return basic_cards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_basic_cards() {
  return &basic_cards_;
}

// optional uint32 gem = 8;
inline bool SinglePlayerInfo::has_gem() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SinglePlayerInfo::set_has_gem() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SinglePlayerInfo::clear_has_gem() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SinglePlayerInfo::clear_gem() {
  gem_ = 0u;
  clear_has_gem();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::gem() const {
  return gem_;
}
inline void SinglePlayerInfo::set_gem(::google::protobuf::uint32 value) {
  set_has_gem();
  gem_ = value;
}

// optional uint32 crystal = 9;
inline bool SinglePlayerInfo::has_crystal() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SinglePlayerInfo::set_has_crystal() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SinglePlayerInfo::clear_has_crystal() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SinglePlayerInfo::clear_crystal() {
  crystal_ = 0u;
  clear_has_crystal();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::crystal() const {
  return crystal_;
}
inline void SinglePlayerInfo::set_crystal(::google::protobuf::uint32 value) {
  set_has_crystal();
  crystal_ = value;
}

// optional uint32 yellow_token = 10;
inline bool SinglePlayerInfo::has_yellow_token() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SinglePlayerInfo::set_has_yellow_token() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SinglePlayerInfo::clear_has_yellow_token() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SinglePlayerInfo::clear_yellow_token() {
  yellow_token_ = 0u;
  clear_has_yellow_token();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::yellow_token() const {
  return yellow_token_;
}
inline void SinglePlayerInfo::set_yellow_token(::google::protobuf::uint32 value) {
  set_has_yellow_token();
  yellow_token_ = value;
}

// optional uint32 blue_token = 11;
inline bool SinglePlayerInfo::has_blue_token() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SinglePlayerInfo::set_has_blue_token() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SinglePlayerInfo::clear_has_blue_token() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SinglePlayerInfo::clear_blue_token() {
  blue_token_ = 0u;
  clear_has_blue_token();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::blue_token() const {
  return blue_token_;
}
inline void SinglePlayerInfo::set_blue_token(::google::protobuf::uint32 value) {
  set_has_blue_token();
  blue_token_ = value;
}

// optional uint32 covered_count = 12;
inline bool SinglePlayerInfo::has_covered_count() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SinglePlayerInfo::set_has_covered_count() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SinglePlayerInfo::clear_has_covered_count() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SinglePlayerInfo::clear_covered_count() {
  covered_count_ = 0u;
  clear_has_covered_count();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::covered_count() const {
  return covered_count_;
}
inline void SinglePlayerInfo::set_covered_count(::google::protobuf::uint32 value) {
  set_has_covered_count();
  covered_count_ = value;
}

// optional bool is_knelt = 13;
inline bool SinglePlayerInfo::has_is_knelt() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SinglePlayerInfo::set_has_is_knelt() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SinglePlayerInfo::clear_has_is_knelt() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SinglePlayerInfo::clear_is_knelt() {
  is_knelt_ = false;
  clear_has_is_knelt();
}
inline bool SinglePlayerInfo::is_knelt() const {
  return is_knelt_;
}
inline void SinglePlayerInfo::set_is_knelt(bool value) {
  set_has_is_knelt();
  is_knelt_ = value;
}

// repeated uint32 hands = 14;
inline int SinglePlayerInfo::hands_size() const {
  return hands_.size();
}
inline void SinglePlayerInfo::clear_hands() {
  hands_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::hands(int index) const {
  return hands_.Get(index);
}
inline void SinglePlayerInfo::set_hands(int index, ::google::protobuf::uint32 value) {
  hands_.Set(index, value);
}
inline void SinglePlayerInfo::add_hands(::google::protobuf::uint32 value) {
  hands_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::hands() const {
  return hands_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_hands() {
  return &hands_;
}

// repeated uint32 covereds = 15;
inline int SinglePlayerInfo::covereds_size() const {
  return covereds_.size();
}
inline void SinglePlayerInfo::clear_covereds() {
  covereds_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::covereds(int index) const {
  return covereds_.Get(index);
}
inline void SinglePlayerInfo::set_covereds(int index, ::google::protobuf::uint32 value) {
  covereds_.Set(index, value);
}
inline void SinglePlayerInfo::add_covereds(::google::protobuf::uint32 value) {
  covereds_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::covereds() const {
  return covereds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_covereds() {
  return &covereds_;
}

// optional uint32 max_hand = 16;
inline bool SinglePlayerInfo::has_max_hand() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SinglePlayerInfo::set_has_max_hand() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SinglePlayerInfo::clear_has_max_hand() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SinglePlayerInfo::clear_max_hand() {
  max_hand_ = 0u;
  clear_has_max_hand();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::max_hand() const {
  return max_hand_;
}
inline void SinglePlayerInfo::set_max_hand(::google::protobuf::uint32 value) {
  set_has_max_hand();
  max_hand_ = value;
}

// optional string nickname = 17;
inline bool SinglePlayerInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SinglePlayerInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SinglePlayerInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SinglePlayerInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& SinglePlayerInfo::nickname() const {
  return *nickname_;
}
inline void SinglePlayerInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void SinglePlayerInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void SinglePlayerInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SinglePlayerInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* SinglePlayerInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SinglePlayerInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool ready = 18 [default = false];
inline bool SinglePlayerInfo::has_ready() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SinglePlayerInfo::set_has_ready() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SinglePlayerInfo::clear_has_ready() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SinglePlayerInfo::clear_ready() {
  ready_ = false;
  clear_has_ready();
}
inline bool SinglePlayerInfo::ready() const {
  return ready_;
}
inline void SinglePlayerInfo::set_ready(bool value) {
  set_has_ready();
  ready_ = value;
}

// repeated string delete_field = 19;
inline int SinglePlayerInfo::delete_field_size() const {
  return delete_field_.size();
}
inline void SinglePlayerInfo::clear_delete_field() {
  delete_field_.Clear();
}
inline const ::std::string& SinglePlayerInfo::delete_field(int index) const {
  return delete_field_.Get(index);
}
inline ::std::string* SinglePlayerInfo::mutable_delete_field(int index) {
  return delete_field_.Mutable(index);
}
inline void SinglePlayerInfo::set_delete_field(int index, const ::std::string& value) {
  delete_field_.Mutable(index)->assign(value);
}
inline void SinglePlayerInfo::set_delete_field(int index, const char* value) {
  delete_field_.Mutable(index)->assign(value);
}
inline void SinglePlayerInfo::set_delete_field(int index, const char* value, size_t size) {
  delete_field_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SinglePlayerInfo::add_delete_field() {
  return delete_field_.Add();
}
inline void SinglePlayerInfo::add_delete_field(const ::std::string& value) {
  delete_field_.Add()->assign(value);
}
inline void SinglePlayerInfo::add_delete_field(const char* value) {
  delete_field_.Add()->assign(value);
}
inline void SinglePlayerInfo::add_delete_field(const char* value, size_t size) {
  delete_field_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SinglePlayerInfo::delete_field() const {
  return delete_field_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SinglePlayerInfo::mutable_delete_field() {
  return &delete_field_;
}

// -------------------------------------------------------------------

// GameInfo

// optional int32 room_id = 1;
inline bool GameInfo::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInfo::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInfo::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInfo::clear_room_id() {
  room_id_ = 0;
  clear_has_room_id();
}
inline ::google::protobuf::int32 GameInfo::room_id() const {
  return room_id_;
}
inline void GameInfo::set_room_id(::google::protobuf::int32 value) {
  set_has_room_id();
  room_id_ = value;
}

// optional int32 player_id = 2;
inline bool GameInfo::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInfo::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInfo::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInfo::clear_player_id() {
  player_id_ = 0;
  clear_has_player_id();
}
inline ::google::protobuf::int32 GameInfo::player_id() const {
  return player_id_;
}
inline void GameInfo::set_player_id(::google::protobuf::int32 value) {
  set_has_player_id();
  player_id_ = value;
}

// optional uint32 red_morale = 3;
inline bool GameInfo::has_red_morale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameInfo::set_has_red_morale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameInfo::clear_has_red_morale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameInfo::clear_red_morale() {
  red_morale_ = 0u;
  clear_has_red_morale();
}
inline ::google::protobuf::uint32 GameInfo::red_morale() const {
  return red_morale_;
}
inline void GameInfo::set_red_morale(::google::protobuf::uint32 value) {
  set_has_red_morale();
  red_morale_ = value;
}

// optional uint32 blue_morale = 4;
inline bool GameInfo::has_blue_morale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameInfo::set_has_blue_morale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameInfo::clear_has_blue_morale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameInfo::clear_blue_morale() {
  blue_morale_ = 0u;
  clear_has_blue_morale();
}
inline ::google::protobuf::uint32 GameInfo::blue_morale() const {
  return blue_morale_;
}
inline void GameInfo::set_blue_morale(::google::protobuf::uint32 value) {
  set_has_blue_morale();
  blue_morale_ = value;
}

// optional uint32 red_gem = 5;
inline bool GameInfo::has_red_gem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameInfo::set_has_red_gem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameInfo::clear_has_red_gem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameInfo::clear_red_gem() {
  red_gem_ = 0u;
  clear_has_red_gem();
}
inline ::google::protobuf::uint32 GameInfo::red_gem() const {
  return red_gem_;
}
inline void GameInfo::set_red_gem(::google::protobuf::uint32 value) {
  set_has_red_gem();
  red_gem_ = value;
}

// optional uint32 blue_gem = 6;
inline bool GameInfo::has_blue_gem() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameInfo::set_has_blue_gem() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameInfo::clear_has_blue_gem() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameInfo::clear_blue_gem() {
  blue_gem_ = 0u;
  clear_has_blue_gem();
}
inline ::google::protobuf::uint32 GameInfo::blue_gem() const {
  return blue_gem_;
}
inline void GameInfo::set_blue_gem(::google::protobuf::uint32 value) {
  set_has_blue_gem();
  blue_gem_ = value;
}

// optional uint32 red_crystal = 7;
inline bool GameInfo::has_red_crystal() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameInfo::set_has_red_crystal() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameInfo::clear_has_red_crystal() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameInfo::clear_red_crystal() {
  red_crystal_ = 0u;
  clear_has_red_crystal();
}
inline ::google::protobuf::uint32 GameInfo::red_crystal() const {
  return red_crystal_;
}
inline void GameInfo::set_red_crystal(::google::protobuf::uint32 value) {
  set_has_red_crystal();
  red_crystal_ = value;
}

// optional uint32 blue_crystal = 8;
inline bool GameInfo::has_blue_crystal() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameInfo::set_has_blue_crystal() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameInfo::clear_has_blue_crystal() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameInfo::clear_blue_crystal() {
  blue_crystal_ = 0u;
  clear_has_blue_crystal();
}
inline ::google::protobuf::uint32 GameInfo::blue_crystal() const {
  return blue_crystal_;
}
inline void GameInfo::set_blue_crystal(::google::protobuf::uint32 value) {
  set_has_blue_crystal();
  blue_crystal_ = value;
}

// optional uint32 red_grail = 9;
inline bool GameInfo::has_red_grail() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameInfo::set_has_red_grail() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameInfo::clear_has_red_grail() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameInfo::clear_red_grail() {
  red_grail_ = 0u;
  clear_has_red_grail();
}
inline ::google::protobuf::uint32 GameInfo::red_grail() const {
  return red_grail_;
}
inline void GameInfo::set_red_grail(::google::protobuf::uint32 value) {
  set_has_red_grail();
  red_grail_ = value;
}

// optional uint32 blue_grail = 10;
inline bool GameInfo::has_blue_grail() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameInfo::set_has_blue_grail() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameInfo::clear_has_blue_grail() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameInfo::clear_blue_grail() {
  blue_grail_ = 0u;
  clear_has_blue_grail();
}
inline ::google::protobuf::uint32 GameInfo::blue_grail() const {
  return blue_grail_;
}
inline void GameInfo::set_blue_grail(::google::protobuf::uint32 value) {
  set_has_blue_grail();
  blue_grail_ = value;
}

// optional uint32 pile = 11;
inline bool GameInfo::has_pile() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameInfo::set_has_pile() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameInfo::clear_has_pile() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameInfo::clear_pile() {
  pile_ = 0u;
  clear_has_pile();
}
inline ::google::protobuf::uint32 GameInfo::pile() const {
  return pile_;
}
inline void GameInfo::set_pile(::google::protobuf::uint32 value) {
  set_has_pile();
  pile_ = value;
}

// optional uint32 discard = 12;
inline bool GameInfo::has_discard() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameInfo::set_has_discard() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameInfo::clear_has_discard() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameInfo::clear_discard() {
  discard_ = 0u;
  clear_has_discard();
}
inline ::google::protobuf::uint32 GameInfo::discard() const {
  return discard_;
}
inline void GameInfo::set_discard(::google::protobuf::uint32 value) {
  set_has_discard();
  discard_ = value;
}

// optional bool is_started = 13 [default = false];
inline bool GameInfo::has_is_started() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameInfo::set_has_is_started() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameInfo::clear_has_is_started() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameInfo::clear_is_started() {
  is_started_ = false;
  clear_has_is_started();
}
inline bool GameInfo::is_started() const {
  return is_started_;
}
inline void GameInfo::set_is_started(bool value) {
  set_has_is_started();
  is_started_ = value;
}

// repeated .network.SinglePlayerInfo player_infos = 14;
inline int GameInfo::player_infos_size() const {
  return player_infos_.size();
}
inline void GameInfo::clear_player_infos() {
  player_infos_.Clear();
}
inline const ::network::SinglePlayerInfo& GameInfo::player_infos(int index) const {
  return player_infos_.Get(index);
}
inline ::network::SinglePlayerInfo* GameInfo::mutable_player_infos(int index) {
  return player_infos_.Mutable(index);
}
inline ::network::SinglePlayerInfo* GameInfo::add_player_infos() {
  return player_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >&
GameInfo::player_infos() const {
  return player_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >*
GameInfo::mutable_player_infos() {
  return &player_infos_;
}

// -------------------------------------------------------------------

// Talk

// optional string txt = 1;
inline bool Talk::has_txt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Talk::set_has_txt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Talk::clear_has_txt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Talk::clear_txt() {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    txt_->clear();
  }
  clear_has_txt();
}
inline const ::std::string& Talk::txt() const {
  return *txt_;
}
inline void Talk::set_txt(const ::std::string& value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void Talk::set_txt(const char* value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void Talk::set_txt(const char* value, size_t size) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Talk::mutable_txt() {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  return txt_;
}
inline ::std::string* Talk::release_txt() {
  clear_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txt_;
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Talk::set_allocated_txt(::std::string* txt) {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    delete txt_;
  }
  if (txt) {
    set_has_txt();
    txt_ = txt;
  } else {
    clear_has_txt();
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Error

// required int32 id = 1;
inline bool Error::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Error::id() const {
  return id_;
}
inline void Error::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 dst_id = 2;
inline bool Error::has_dst_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_dst_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_dst_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_dst_id() {
  dst_id_ = 0;
  clear_has_dst_id();
}
inline ::google::protobuf::int32 Error::dst_id() const {
  return dst_id_;
}
inline void Error::set_dst_id(::google::protobuf::int32 value) {
  set_has_dst_id();
  dst_id_ = value;
}

// repeated int32 args = 3;
inline int Error::args_size() const {
  return args_.size();
}
inline void Error::clear_args() {
  args_.Clear();
}
inline ::google::protobuf::int32 Error::args(int index) const {
  return args_.Get(index);
}
inline void Error::set_args(int index, ::google::protobuf::int32 value) {
  args_.Set(index, value);
}
inline void Error::add_args(::google::protobuf::int32 value) {
  args_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Error::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Error::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// Gossip

// optional .network.GossipType type = 1;
inline bool Gossip::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gossip::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gossip::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gossip::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::network::GossipType Gossip::type() const {
  return static_cast< ::network::GossipType >(type_);
}
inline void Gossip::set_type(::network::GossipType value) {
  assert(::network::GossipType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string txt = 2;
inline bool Gossip::has_txt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gossip::set_has_txt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gossip::clear_has_txt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gossip::clear_txt() {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    txt_->clear();
  }
  clear_has_txt();
}
inline const ::std::string& Gossip::txt() const {
  return *txt_;
}
inline void Gossip::set_txt(const ::std::string& value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void Gossip::set_txt(const char* value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void Gossip::set_txt(const char* value, size_t size) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Gossip::mutable_txt() {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  return txt_;
}
inline ::std::string* Gossip::release_txt() {
  clear_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txt_;
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Gossip::set_allocated_txt(::std::string* txt) {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    delete txt_;
  }
  if (txt) {
    set_has_txt();
    txt_ = txt;
  } else {
    clear_has_txt();
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 id = 3;
inline bool Gossip::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gossip::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gossip::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gossip::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Gossip::id() const {
  return id_;
}
inline void Gossip::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// HeartBeat


// @@protoc_insertion_point(namespace_scope)

}  // namespace network

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::network::JoinTeamRequest_Team>() {
  return ::network::JoinTeamRequest_Team_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::network::ReadyForGameRequest_Type>() {
  return ::network::ReadyForGameRequest_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::network::MessageType>() {
  return ::network::MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::network::GossipType>() {
  return ::network::GossipType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_base_2eproto__INCLUDED
