// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base.proto

#ifndef PROTOBUF_base_2eproto__INCLUDED
#define PROTOBUF_base_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "action_respond.pb.h"
// @@protoc_insertion_point(includes)

namespace network {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_base_2eproto();
void protobuf_AssignDesc_base_2eproto();
void protobuf_ShutdownFile_base_2eproto();

class BecomeLeaderRequest;
class BecomeLeaderResponse;
class CreateRoomRequest;
class EnterRoomRequest;
class Error;
class GameInfo;
class Gossip;
class HeartBeat;
class JoinTeamRequest;
class LeaveRoomRequest;
class LoginRequest;
class LoginResponse;
class LogoutRequest;
class LogoutResponse;
class PollingRequest;
class PollingResponse;
class ReadyForGameRequest;
class RegisterRequest;
class RegisterResponse;
class RoomListRequest;
class RoomListResponse;
class RoomListResponse_RoomInfo;
class SinglePlayerInfo;
class Talk;

enum JoinTeamRequest_Team {
  JoinTeamRequest_Team_TEAM_A = 1,
  JoinTeamRequest_Team_TEAM_B = 0,
  JoinTeamRequest_Team_TEAM_RANDOM = 2
};
bool JoinTeamRequest_Team_IsValid(int value);
const JoinTeamRequest_Team JoinTeamRequest_Team_Team_MIN = JoinTeamRequest_Team_TEAM_B;
const JoinTeamRequest_Team JoinTeamRequest_Team_Team_MAX = JoinTeamRequest_Team_TEAM_RANDOM;
const int JoinTeamRequest_Team_Team_ARRAYSIZE = JoinTeamRequest_Team_Team_MAX + 1;

const ::google::protobuf::EnumDescriptor* JoinTeamRequest_Team_descriptor();
inline const ::std::string& JoinTeamRequest_Team_Name(JoinTeamRequest_Team value) {
  return ::google::protobuf::internal::NameOfEnum(
    JoinTeamRequest_Team_descriptor(), value);
}
inline bool JoinTeamRequest_Team_Parse(
    const ::std::string& name, JoinTeamRequest_Team* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JoinTeamRequest_Team>(
    JoinTeamRequest_Team_descriptor(), name, value);
}
enum ReadyForGameRequest_Type {
  ReadyForGameRequest_Type_START_READY = 1,
  ReadyForGameRequest_Type_CANCEL_START_REDAY = 2
};
bool ReadyForGameRequest_Type_IsValid(int value);
const ReadyForGameRequest_Type ReadyForGameRequest_Type_Type_MIN = ReadyForGameRequest_Type_START_READY;
const ReadyForGameRequest_Type ReadyForGameRequest_Type_Type_MAX = ReadyForGameRequest_Type_CANCEL_START_REDAY;
const int ReadyForGameRequest_Type_Type_ARRAYSIZE = ReadyForGameRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReadyForGameRequest_Type_descriptor();
inline const ::std::string& ReadyForGameRequest_Type_Name(ReadyForGameRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReadyForGameRequest_Type_descriptor(), value);
}
inline bool ReadyForGameRequest_Type_Parse(
    const ::std::string& name, ReadyForGameRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReadyForGameRequest_Type>(
    ReadyForGameRequest_Type_descriptor(), name, value);
}
enum MessageType {
  MSG_REGISTER_REQ = 1,
  MSG_REGISTER_REP = 2,
  MSG_LOGIN_REQ = 3,
  MSG_LOGIN_REP = 4,
  MSG_LOGOUT_REQ = 5,
  MSG_LOGOUT_REP = 6,
  MSG_ROOMLIST_REQ = 7,
  MSG_ROOMLIST_REP = 8,
  MSG_CREATE_ROOM_REQ = 9,
  MSG_ENTER_ROOM_REQ = 10,
  MSG_ENTER_ROOM_REP = 11,
  MSG_LEAVE_ROOM_REQ = 12,
  MSG_JOIN_TEAM_REQ = 13,
  MSG_READY_GAME_REQ = 14,
  MSG_SINGLE_PLAYER = 15,
  MSG_GAME = 16,
  MSG_TALK = 17,
  MSG_GOSSIP = 18,
  MSG_ERROR = 19,
  MSG_HEARTBEAT = 20,
  MSG_BECOME_LEADER_REQ = 21,
  MSG_BECOME_LEADER_REP = 22,
  MSG_POLLING_REQ = 23,
  MSG_POLLING_REP = 24
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = MSG_REGISTER_REQ;
const MessageType MessageType_MAX = MSG_POLLING_REP;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum GossipType {
  GOSSIP_TALK = 1,
  GOSSIP_NOTICE = 2
};
bool GossipType_IsValid(int value);
const GossipType GossipType_MIN = GOSSIP_TALK;
const GossipType GossipType_MAX = GOSSIP_NOTICE;
const int GossipType_ARRAYSIZE = GossipType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GossipType_descriptor();
inline const ::std::string& GossipType_Name(GossipType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GossipType_descriptor(), value);
}
inline bool GossipType_Parse(
    const ::std::string& name, GossipType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GossipType>(
    GossipType_descriptor(), name, value);
}
// ===================================================================

class RegisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.RegisterRequest) */ {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  void Swap(RegisterRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterRequest* New() const { return New(NULL); }

  RegisterRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional string user_password = 2;
  bool has_user_password() const;
  void clear_user_password();
  static const int kUserPasswordFieldNumber = 2;
  const ::std::string& user_password() const;
  void set_user_password(const ::std::string& value);
  void set_user_password(const char* value);
  void set_user_password(const char* value, size_t size);
  ::std::string* mutable_user_password();
  ::std::string* release_user_password();
  void set_allocated_user_password(::std::string* user_password);

  // optional string nickname = 3;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // optional string mobile = 4;
  bool has_mobile() const;
  void clear_mobile();
  static const int kMobileFieldNumber = 4;
  const ::std::string& mobile() const;
  void set_mobile(const ::std::string& value);
  void set_mobile(const char* value);
  void set_mobile(const char* value, size_t size);
  ::std::string* mutable_mobile();
  ::std::string* release_mobile();
  void set_allocated_mobile(::std::string* mobile);

  // optional string email = 5;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 5;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:network.RegisterRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_password();
  inline void clear_has_user_password();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_email();
  inline void clear_has_email();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr user_password_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::internal::ArenaStringPtr mobile_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RegisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponse& default_instance();

  void Swap(RegisterResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const { return New(NULL); }

  RegisterResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::google::protobuf::uint32 state() const;
  void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:network.RegisterResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 state_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RegisterResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const { return New(NULL); }

  LoginRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool asGuest = 1;
  bool has_asguest() const;
  void clear_asguest();
  static const int kAsGuestFieldNumber = 1;
  bool asguest() const;
  void set_asguest(bool value);

  // optional string user_id = 2;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional string user_password = 3;
  bool has_user_password() const;
  void clear_user_password();
  static const int kUserPasswordFieldNumber = 3;
  const ::std::string& user_password() const;
  void set_user_password(const ::std::string& value);
  void set_user_password(const char* value);
  void set_user_password(const char* value, size_t size);
  ::std::string* mutable_user_password();
  ::std::string* release_user_password();
  void set_allocated_user_password(::std::string* user_password);

  // optional int32 version = 4 [default = -1];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:network.LoginRequest)
 private:
  inline void set_has_asguest();
  inline void clear_has_asguest();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_password();
  inline void clear_has_user_password();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  bool asguest_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::internal::ArenaStringPtr user_password_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const { return New(NULL); }

  LoginResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // optional string nickname = 2;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:network.LoginResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::int32 state_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogoutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.LogoutRequest) */ {
 public:
  LogoutRequest();
  virtual ~LogoutRequest();

  LogoutRequest(const LogoutRequest& from);

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRequest& default_instance();

  void Swap(LogoutRequest* other);

  // implements Message ----------------------------------------------

  inline LogoutRequest* New() const { return New(NULL); }

  LogoutRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogoutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:network.LogoutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LogoutRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogoutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.LogoutResponse) */ {
 public:
  LogoutResponse();
  virtual ~LogoutResponse();

  LogoutResponse(const LogoutResponse& from);

  inline LogoutResponse& operator=(const LogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutResponse& default_instance();

  void Swap(LogoutResponse* other);

  // implements Message ----------------------------------------------

  inline LogoutResponse* New() const { return New(NULL); }

  LogoutResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutResponse& from);
  void MergeFrom(const LogoutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogoutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 args = 1;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 1;
  ::google::protobuf::uint32 args(int index) const;
  void set_args(int index, ::google::protobuf::uint32 value);
  void add_args(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      args() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_args();

  // @@protoc_insertion_point(class_scope:network.LogoutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > args_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LogoutResponse* default_instance_;
};
// -------------------------------------------------------------------

class RoomListRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.RoomListRequest) */ {
 public:
  RoomListRequest();
  virtual ~RoomListRequest();

  RoomListRequest(const RoomListRequest& from);

  inline RoomListRequest& operator=(const RoomListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListRequest& default_instance();

  void Swap(RoomListRequest* other);

  // implements Message ----------------------------------------------

  inline RoomListRequest* New() const { return New(NULL); }

  RoomListRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListRequest& from);
  void MergeFrom(const RoomListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoomListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .network.ROLE_STRATEGY role_strategy = 1;
  bool has_role_strategy() const;
  void clear_role_strategy();
  static const int kRoleStrategyFieldNumber = 1;
  ::network::ROLE_STRATEGY role_strategy() const;
  void set_role_strategy(::network::ROLE_STRATEGY value);

  // @@protoc_insertion_point(class_scope:network.RoomListRequest)
 private:
  inline void set_has_role_strategy();
  inline void clear_has_role_strategy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int role_strategy_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RoomListRequest* default_instance_;
};
// -------------------------------------------------------------------

class RoomListResponse_RoomInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.RoomListResponse.RoomInfo) */ {
 public:
  RoomListResponse_RoomInfo();
  virtual ~RoomListResponse_RoomInfo();

  RoomListResponse_RoomInfo(const RoomListResponse_RoomInfo& from);

  inline RoomListResponse_RoomInfo& operator=(const RoomListResponse_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListResponse_RoomInfo& default_instance();

  void Swap(RoomListResponse_RoomInfo* other);

  // implements Message ----------------------------------------------

  inline RoomListResponse_RoomInfo* New() const { return New(NULL); }

  RoomListResponse_RoomInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListResponse_RoomInfo& from);
  void MergeFrom(const RoomListResponse_RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoomListResponse_RoomInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 room_id = 1;
  bool has_room_id() const;
  void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::int32 room_id() const;
  void set_room_id(::google::protobuf::int32 value);

  // optional string room_name = 2;
  bool has_room_name() const;
  void clear_room_name();
  static const int kRoomNameFieldNumber = 2;
  const ::std::string& room_name() const;
  void set_room_name(const ::std::string& value);
  void set_room_name(const char* value);
  void set_room_name(const char* value, size_t size);
  ::std::string* mutable_room_name();
  ::std::string* release_room_name();
  void set_allocated_room_name(::std::string* room_name);

  // optional int32 max_player = 3;
  bool has_max_player() const;
  void clear_max_player();
  static const int kMaxPlayerFieldNumber = 3;
  ::google::protobuf::int32 max_player() const;
  void set_max_player(::google::protobuf::int32 value);

  // optional int32 now_player = 4;
  bool has_now_player() const;
  void clear_now_player();
  static const int kNowPlayerFieldNumber = 4;
  ::google::protobuf::int32 now_player() const;
  void set_now_player(::google::protobuf::int32 value);

  // optional .network.ROLE_STRATEGY role_strategy = 5;
  bool has_role_strategy() const;
  void clear_role_strategy();
  static const int kRoleStrategyFieldNumber = 5;
  ::network::ROLE_STRATEGY role_strategy() const;
  void set_role_strategy(::network::ROLE_STRATEGY value);

  // optional int32 seat_mode = 6;
  bool has_seat_mode() const;
  void clear_seat_mode();
  static const int kSeatModeFieldNumber = 6;
  ::google::protobuf::int32 seat_mode() const;
  void set_seat_mode(::google::protobuf::int32 value);

  // optional int32 role_range = 7;
  bool has_role_range() const;
  void clear_role_range();
  static const int kRoleRangeFieldNumber = 7;
  ::google::protobuf::int32 role_range() const;
  void set_role_range(::google::protobuf::int32 value);

  // optional bool allow_guest = 8 [default = true];
  bool has_allow_guest() const;
  void clear_allow_guest();
  static const int kAllowGuestFieldNumber = 8;
  bool allow_guest() const;
  void set_allow_guest(bool value);

  // optional bool has_password = 9 [default = false];
  bool has_has_password() const;
  void clear_has_password();
  static const int kHasPasswordFieldNumber = 9;
  bool has_password() const;
  void set_has_password(bool value);

  // optional bool first_extension = 10;
  bool has_first_extension() const;
  void clear_first_extension();
  static const int kFirstExtensionFieldNumber = 10;
  bool first_extension() const;
  void set_first_extension(bool value);

  // optional bool second_extension = 11;
  bool has_second_extension() const;
  void clear_second_extension();
  static const int kSecondExtensionFieldNumber = 11;
  bool second_extension() const;
  void set_second_extension(bool value);

  // optional bool sp_mo_dao = 12;
  bool has_sp_mo_dao() const;
  void clear_sp_mo_dao();
  static const int kSpMoDaoFieldNumber = 12;
  bool sp_mo_dao() const;
  void set_sp_mo_dao(bool value);

  // optional bool playing = 13 [default = false];
  bool has_playing() const;
  void clear_playing();
  static const int kPlayingFieldNumber = 13;
  bool playing() const;
  void set_playing(bool value);

  // optional bool silence = 14 [default = false];
  bool has_silence() const;
  void clear_silence();
  static const int kSilenceFieldNumber = 14;
  bool silence() const;
  void set_silence(bool value);

  // @@protoc_insertion_point(class_scope:network.RoomListResponse.RoomInfo)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_room_name();
  inline void clear_has_room_name();
  inline void set_has_max_player();
  inline void clear_has_max_player();
  inline void set_has_now_player();
  inline void clear_has_now_player();
  inline void set_has_role_strategy();
  inline void clear_has_role_strategy();
  inline void set_has_seat_mode();
  inline void clear_has_seat_mode();
  inline void set_has_role_range();
  inline void clear_has_role_range();
  inline void set_has_allow_guest();
  inline void clear_has_allow_guest();
  inline void set_has_has_password();
  inline void clear_has_has_password();
  inline void set_has_first_extension();
  inline void clear_has_first_extension();
  inline void set_has_second_extension();
  inline void clear_has_second_extension();
  inline void set_has_sp_mo_dao();
  inline void clear_has_sp_mo_dao();
  inline void set_has_playing();
  inline void clear_has_playing();
  inline void set_has_silence();
  inline void clear_has_silence();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr room_name_;
  ::google::protobuf::int32 room_id_;
  ::google::protobuf::int32 max_player_;
  ::google::protobuf::int32 now_player_;
  int role_strategy_;
  ::google::protobuf::int32 seat_mode_;
  ::google::protobuf::int32 role_range_;
  bool allow_guest_;
  bool has_password_;
  bool first_extension_;
  bool second_extension_;
  bool sp_mo_dao_;
  bool playing_;
  bool silence_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RoomListResponse_RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomListResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.RoomListResponse) */ {
 public:
  RoomListResponse();
  virtual ~RoomListResponse();

  RoomListResponse(const RoomListResponse& from);

  inline RoomListResponse& operator=(const RoomListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListResponse& default_instance();

  void Swap(RoomListResponse* other);

  // implements Message ----------------------------------------------

  inline RoomListResponse* New() const { return New(NULL); }

  RoomListResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListResponse& from);
  void MergeFrom(const RoomListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoomListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomListResponse_RoomInfo RoomInfo;

  // accessors -------------------------------------------------------

  // repeated .network.RoomListResponse.RoomInfo rooms = 1;
  int rooms_size() const;
  void clear_rooms();
  static const int kRoomsFieldNumber = 1;
  const ::network::RoomListResponse_RoomInfo& rooms(int index) const;
  ::network::RoomListResponse_RoomInfo* mutable_rooms(int index);
  ::network::RoomListResponse_RoomInfo* add_rooms();
  ::google::protobuf::RepeatedPtrField< ::network::RoomListResponse_RoomInfo >*
      mutable_rooms();
  const ::google::protobuf::RepeatedPtrField< ::network::RoomListResponse_RoomInfo >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:network.RoomListResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::network::RoomListResponse_RoomInfo > rooms_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RoomListResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.CreateRoomRequest) */ {
 public:
  CreateRoomRequest();
  virtual ~CreateRoomRequest();

  CreateRoomRequest(const CreateRoomRequest& from);

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomRequest& default_instance();

  void Swap(CreateRoomRequest* other);

  // implements Message ----------------------------------------------

  inline CreateRoomRequest* New() const { return New(NULL); }

  CreateRoomRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomRequest& from);
  void MergeFrom(const CreateRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateRoomRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string room_name = 1;
  bool has_room_name() const;
  void clear_room_name();
  static const int kRoomNameFieldNumber = 1;
  const ::std::string& room_name() const;
  void set_room_name(const ::std::string& value);
  void set_room_name(const char* value);
  void set_room_name(const char* value, size_t size);
  ::std::string* mutable_room_name();
  ::std::string* release_room_name();
  void set_allocated_room_name(::std::string* room_name);

  // optional int32 max_player = 2;
  bool has_max_player() const;
  void clear_max_player();
  static const int kMaxPlayerFieldNumber = 2;
  ::google::protobuf::int32 max_player() const;
  void set_max_player(::google::protobuf::int32 value);

  // optional .network.ROLE_STRATEGY role_strategy = 3;
  bool has_role_strategy() const;
  void clear_role_strategy();
  static const int kRoleStrategyFieldNumber = 3;
  ::network::ROLE_STRATEGY role_strategy() const;
  void set_role_strategy(::network::ROLE_STRATEGY value);

  // optional bool first_extension = 4;
  bool has_first_extension() const;
  void clear_first_extension();
  static const int kFirstExtensionFieldNumber = 4;
  bool first_extension() const;
  void set_first_extension(bool value);

  // optional bool second_extension = 5;
  bool has_second_extension() const;
  void clear_second_extension();
  static const int kSecondExtensionFieldNumber = 5;
  bool second_extension() const;
  void set_second_extension(bool value);

  // optional bool sp_mo_dao = 6;
  bool has_sp_mo_dao() const;
  void clear_sp_mo_dao();
  static const int kSpMoDaoFieldNumber = 6;
  bool sp_mo_dao() const;
  void set_sp_mo_dao(bool value);

  // optional int32 seat_mode = 7;
  bool has_seat_mode() const;
  void clear_seat_mode();
  static const int kSeatModeFieldNumber = 7;
  ::google::protobuf::int32 seat_mode() const;
  void set_seat_mode(::google::protobuf::int32 value);

  // optional bool allow_guest = 8 [default = true];
  bool has_allow_guest() const;
  void clear_allow_guest();
  static const int kAllowGuestFieldNumber = 8;
  bool allow_guest() const;
  void set_allow_guest(bool value);

  // optional string password = 9 [default = ""];
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 9;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional bool silence = 10 [default = false];
  bool has_silence() const;
  void clear_silence();
  static const int kSilenceFieldNumber = 10;
  bool silence() const;
  void set_silence(bool value);

  // @@protoc_insertion_point(class_scope:network.CreateRoomRequest)
 private:
  inline void set_has_room_name();
  inline void clear_has_room_name();
  inline void set_has_max_player();
  inline void clear_has_max_player();
  inline void set_has_role_strategy();
  inline void clear_has_role_strategy();
  inline void set_has_first_extension();
  inline void clear_has_first_extension();
  inline void set_has_second_extension();
  inline void clear_has_second_extension();
  inline void set_has_sp_mo_dao();
  inline void clear_has_sp_mo_dao();
  inline void set_has_seat_mode();
  inline void clear_has_seat_mode();
  inline void set_has_allow_guest();
  inline void clear_has_allow_guest();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_silence();
  inline void clear_has_silence();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr room_name_;
  ::google::protobuf::int32 max_player_;
  int role_strategy_;
  bool first_extension_;
  bool second_extension_;
  bool sp_mo_dao_;
  bool allow_guest_;
  ::google::protobuf::int32 seat_mode_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  bool silence_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static CreateRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.EnterRoomRequest) */ {
 public:
  EnterRoomRequest();
  virtual ~EnterRoomRequest();

  EnterRoomRequest(const EnterRoomRequest& from);

  inline EnterRoomRequest& operator=(const EnterRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomRequest& default_instance();

  void Swap(EnterRoomRequest* other);

  // implements Message ----------------------------------------------

  inline EnterRoomRequest* New() const { return New(NULL); }

  EnterRoomRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoomRequest& from);
  void MergeFrom(const EnterRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnterRoomRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 room_id = 1;
  bool has_room_id() const;
  void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::int32 room_id() const;
  void set_room_id(::google::protobuf::int32 value);

  // optional string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:network.EnterRoomRequest)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::int32 room_id_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static EnterRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class LeaveRoomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.LeaveRoomRequest) */ {
 public:
  LeaveRoomRequest();
  virtual ~LeaveRoomRequest();

  LeaveRoomRequest(const LeaveRoomRequest& from);

  inline LeaveRoomRequest& operator=(const LeaveRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveRoomRequest& default_instance();

  void Swap(LeaveRoomRequest* other);

  // implements Message ----------------------------------------------

  inline LeaveRoomRequest* New() const { return New(NULL); }

  LeaveRoomRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveRoomRequest& from);
  void MergeFrom(const LeaveRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LeaveRoomRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:network.LeaveRoomRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LeaveRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class JoinTeamRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.JoinTeamRequest) */ {
 public:
  JoinTeamRequest();
  virtual ~JoinTeamRequest();

  JoinTeamRequest(const JoinTeamRequest& from);

  inline JoinTeamRequest& operator=(const JoinTeamRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinTeamRequest& default_instance();

  void Swap(JoinTeamRequest* other);

  // implements Message ----------------------------------------------

  inline JoinTeamRequest* New() const { return New(NULL); }

  JoinTeamRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinTeamRequest& from);
  void MergeFrom(const JoinTeamRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinTeamRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef JoinTeamRequest_Team Team;
  static const Team TEAM_A =
    JoinTeamRequest_Team_TEAM_A;
  static const Team TEAM_B =
    JoinTeamRequest_Team_TEAM_B;
  static const Team TEAM_RANDOM =
    JoinTeamRequest_Team_TEAM_RANDOM;
  static inline bool Team_IsValid(int value) {
    return JoinTeamRequest_Team_IsValid(value);
  }
  static const Team Team_MIN =
    JoinTeamRequest_Team_Team_MIN;
  static const Team Team_MAX =
    JoinTeamRequest_Team_Team_MAX;
  static const int Team_ARRAYSIZE =
    JoinTeamRequest_Team_Team_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Team_descriptor() {
    return JoinTeamRequest_Team_descriptor();
  }
  static inline const ::std::string& Team_Name(Team value) {
    return JoinTeamRequest_Team_Name(value);
  }
  static inline bool Team_Parse(const ::std::string& name,
      Team* value) {
    return JoinTeamRequest_Team_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .network.JoinTeamRequest.Team team = 1;
  bool has_team() const;
  void clear_team();
  static const int kTeamFieldNumber = 1;
  ::network::JoinTeamRequest_Team team() const;
  void set_team(::network::JoinTeamRequest_Team value);

  // @@protoc_insertion_point(class_scope:network.JoinTeamRequest)
 private:
  inline void set_has_team();
  inline void clear_has_team();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int team_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static JoinTeamRequest* default_instance_;
};
// -------------------------------------------------------------------

class BecomeLeaderRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.BecomeLeaderRequest) */ {
 public:
  BecomeLeaderRequest();
  virtual ~BecomeLeaderRequest();

  BecomeLeaderRequest(const BecomeLeaderRequest& from);

  inline BecomeLeaderRequest& operator=(const BecomeLeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BecomeLeaderRequest& default_instance();

  void Swap(BecomeLeaderRequest* other);

  // implements Message ----------------------------------------------

  inline BecomeLeaderRequest* New() const { return New(NULL); }

  BecomeLeaderRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BecomeLeaderRequest& from);
  void MergeFrom(const BecomeLeaderRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BecomeLeaderRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:network.BecomeLeaderRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static BecomeLeaderRequest* default_instance_;
};
// -------------------------------------------------------------------

class BecomeLeaderResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.BecomeLeaderResponse) */ {
 public:
  BecomeLeaderResponse();
  virtual ~BecomeLeaderResponse();

  BecomeLeaderResponse(const BecomeLeaderResponse& from);

  inline BecomeLeaderResponse& operator=(const BecomeLeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BecomeLeaderResponse& default_instance();

  void Swap(BecomeLeaderResponse* other);

  // implements Message ----------------------------------------------

  inline BecomeLeaderResponse* New() const { return New(NULL); }

  BecomeLeaderResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BecomeLeaderResponse& from);
  void MergeFrom(const BecomeLeaderResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BecomeLeaderResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool yes = 1 [default = false];
  bool has_yes() const;
  void clear_yes();
  static const int kYesFieldNumber = 1;
  bool yes() const;
  void set_yes(bool value);

  // @@protoc_insertion_point(class_scope:network.BecomeLeaderResponse)
 private:
  inline void set_has_yes();
  inline void clear_has_yes();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool yes_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static BecomeLeaderResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReadyForGameRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.ReadyForGameRequest) */ {
 public:
  ReadyForGameRequest();
  virtual ~ReadyForGameRequest();

  ReadyForGameRequest(const ReadyForGameRequest& from);

  inline ReadyForGameRequest& operator=(const ReadyForGameRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadyForGameRequest& default_instance();

  void Swap(ReadyForGameRequest* other);

  // implements Message ----------------------------------------------

  inline ReadyForGameRequest* New() const { return New(NULL); }

  ReadyForGameRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadyForGameRequest& from);
  void MergeFrom(const ReadyForGameRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadyForGameRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReadyForGameRequest_Type Type;
  static const Type START_READY =
    ReadyForGameRequest_Type_START_READY;
  static const Type CANCEL_START_REDAY =
    ReadyForGameRequest_Type_CANCEL_START_REDAY;
  static inline bool Type_IsValid(int value) {
    return ReadyForGameRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ReadyForGameRequest_Type_Type_MIN;
  static const Type Type_MAX =
    ReadyForGameRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ReadyForGameRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ReadyForGameRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ReadyForGameRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ReadyForGameRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .network.ReadyForGameRequest.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::network::ReadyForGameRequest_Type type() const;
  void set_type(::network::ReadyForGameRequest_Type value);

  // @@protoc_insertion_point(class_scope:network.ReadyForGameRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static ReadyForGameRequest* default_instance_;
};
// -------------------------------------------------------------------

class SinglePlayerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.SinglePlayerInfo) */ {
 public:
  SinglePlayerInfo();
  virtual ~SinglePlayerInfo();

  SinglePlayerInfo(const SinglePlayerInfo& from);

  inline SinglePlayerInfo& operator=(const SinglePlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SinglePlayerInfo& default_instance();

  void Swap(SinglePlayerInfo* other);

  // implements Message ----------------------------------------------

  inline SinglePlayerInfo* New() const { return New(NULL); }

  SinglePlayerInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SinglePlayerInfo& from);
  void MergeFrom(const SinglePlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SinglePlayerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional uint32 team = 2;
  bool has_team() const;
  void clear_team();
  static const int kTeamFieldNumber = 2;
  ::google::protobuf::uint32 team() const;
  void set_team(::google::protobuf::uint32 value);

  // optional uint32 role_id = 3;
  bool has_role_id() const;
  void clear_role_id();
  static const int kRoleIdFieldNumber = 3;
  ::google::protobuf::uint32 role_id() const;
  void set_role_id(::google::protobuf::uint32 value);

  // optional uint32 hand_count = 4;
  bool has_hand_count() const;
  void clear_hand_count();
  static const int kHandCountFieldNumber = 4;
  ::google::protobuf::uint32 hand_count() const;
  void set_hand_count(::google::protobuf::uint32 value);

  // optional uint32 heal_count = 5;
  bool has_heal_count() const;
  void clear_heal_count();
  static const int kHealCountFieldNumber = 5;
  ::google::protobuf::uint32 heal_count() const;
  void set_heal_count(::google::protobuf::uint32 value);

  // repeated uint32 ex_cards = 6;
  int ex_cards_size() const;
  void clear_ex_cards();
  static const int kExCardsFieldNumber = 6;
  ::google::protobuf::uint32 ex_cards(int index) const;
  void set_ex_cards(int index, ::google::protobuf::uint32 value);
  void add_ex_cards(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ex_cards() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ex_cards();

  // repeated uint32 basic_cards = 7;
  int basic_cards_size() const;
  void clear_basic_cards();
  static const int kBasicCardsFieldNumber = 7;
  ::google::protobuf::uint32 basic_cards(int index) const;
  void set_basic_cards(int index, ::google::protobuf::uint32 value);
  void add_basic_cards(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      basic_cards() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_basic_cards();

  // optional uint32 gem = 8;
  bool has_gem() const;
  void clear_gem();
  static const int kGemFieldNumber = 8;
  ::google::protobuf::uint32 gem() const;
  void set_gem(::google::protobuf::uint32 value);

  // optional uint32 crystal = 9;
  bool has_crystal() const;
  void clear_crystal();
  static const int kCrystalFieldNumber = 9;
  ::google::protobuf::uint32 crystal() const;
  void set_crystal(::google::protobuf::uint32 value);

  // optional uint32 yellow_token = 10;
  bool has_yellow_token() const;
  void clear_yellow_token();
  static const int kYellowTokenFieldNumber = 10;
  ::google::protobuf::uint32 yellow_token() const;
  void set_yellow_token(::google::protobuf::uint32 value);

  // optional uint32 blue_token = 11;
  bool has_blue_token() const;
  void clear_blue_token();
  static const int kBlueTokenFieldNumber = 11;
  ::google::protobuf::uint32 blue_token() const;
  void set_blue_token(::google::protobuf::uint32 value);

  // optional uint32 covered_count = 12;
  bool has_covered_count() const;
  void clear_covered_count();
  static const int kCoveredCountFieldNumber = 12;
  ::google::protobuf::uint32 covered_count() const;
  void set_covered_count(::google::protobuf::uint32 value);

  // optional bool is_knelt = 13;
  bool has_is_knelt() const;
  void clear_is_knelt();
  static const int kIsKneltFieldNumber = 13;
  bool is_knelt() const;
  void set_is_knelt(bool value);

  // repeated uint32 hands = 14;
  int hands_size() const;
  void clear_hands();
  static const int kHandsFieldNumber = 14;
  ::google::protobuf::uint32 hands(int index) const;
  void set_hands(int index, ::google::protobuf::uint32 value);
  void add_hands(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      hands() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_hands();

  // repeated uint32 covereds = 15;
  int covereds_size() const;
  void clear_covereds();
  static const int kCoveredsFieldNumber = 15;
  ::google::protobuf::uint32 covereds(int index) const;
  void set_covereds(int index, ::google::protobuf::uint32 value);
  void add_covereds(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      covereds() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_covereds();

  // optional uint32 max_hand = 16;
  bool has_max_hand() const;
  void clear_max_hand();
  static const int kMaxHandFieldNumber = 16;
  ::google::protobuf::uint32 max_hand() const;
  void set_max_hand(::google::protobuf::uint32 value);

  // optional string nickname = 17;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNicknameFieldNumber = 17;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // optional bool ready = 18 [default = false];
  bool has_ready() const;
  void clear_ready();
  static const int kReadyFieldNumber = 18;
  bool ready() const;
  void set_ready(bool value);

  // repeated string delete_field = 19;
  int delete_field_size() const;
  void clear_delete_field();
  static const int kDeleteFieldFieldNumber = 19;
  const ::std::string& delete_field(int index) const;
  ::std::string* mutable_delete_field(int index);
  void set_delete_field(int index, const ::std::string& value);
  void set_delete_field(int index, const char* value);
  void set_delete_field(int index, const char* value, size_t size);
  ::std::string* add_delete_field();
  void add_delete_field(const ::std::string& value);
  void add_delete_field(const char* value);
  void add_delete_field(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& delete_field() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_delete_field();

  // optional uint32 leader = 20;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 20;
  ::google::protobuf::uint32 leader() const;
  void set_leader(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:network.SinglePlayerInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_hand_count();
  inline void clear_has_hand_count();
  inline void set_has_heal_count();
  inline void clear_has_heal_count();
  inline void set_has_gem();
  inline void clear_has_gem();
  inline void set_has_crystal();
  inline void clear_has_crystal();
  inline void set_has_yellow_token();
  inline void clear_has_yellow_token();
  inline void set_has_blue_token();
  inline void clear_has_blue_token();
  inline void set_has_covered_count();
  inline void clear_has_covered_count();
  inline void set_has_is_knelt();
  inline void clear_has_is_knelt();
  inline void set_has_max_hand();
  inline void clear_has_max_hand();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_ready();
  inline void clear_has_ready();
  inline void set_has_leader();
  inline void clear_has_leader();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 team_;
  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 hand_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ex_cards_;
  ::google::protobuf::uint32 heal_count_;
  ::google::protobuf::uint32 gem_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > basic_cards_;
  ::google::protobuf::uint32 crystal_;
  ::google::protobuf::uint32 yellow_token_;
  ::google::protobuf::uint32 blue_token_;
  ::google::protobuf::uint32 covered_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > hands_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > covereds_;
  bool is_knelt_;
  bool ready_;
  ::google::protobuf::uint32 max_hand_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> delete_field_;
  ::google::protobuf::uint32 leader_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static SinglePlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.GameInfo) */ {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  void Swap(GameInfo* other);

  // implements Message ----------------------------------------------

  inline GameInfo* New() const { return New(NULL); }

  GameInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 room_id = 1;
  bool has_room_id() const;
  void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::int32 room_id() const;
  void set_room_id(::google::protobuf::int32 value);

  // optional int32 player_id = 2;
  bool has_player_id() const;
  void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int32 player_id() const;
  void set_player_id(::google::protobuf::int32 value);

  // optional uint32 red_morale = 3;
  bool has_red_morale() const;
  void clear_red_morale();
  static const int kRedMoraleFieldNumber = 3;
  ::google::protobuf::uint32 red_morale() const;
  void set_red_morale(::google::protobuf::uint32 value);

  // optional uint32 blue_morale = 4;
  bool has_blue_morale() const;
  void clear_blue_morale();
  static const int kBlueMoraleFieldNumber = 4;
  ::google::protobuf::uint32 blue_morale() const;
  void set_blue_morale(::google::protobuf::uint32 value);

  // optional uint32 red_gem = 5;
  bool has_red_gem() const;
  void clear_red_gem();
  static const int kRedGemFieldNumber = 5;
  ::google::protobuf::uint32 red_gem() const;
  void set_red_gem(::google::protobuf::uint32 value);

  // optional uint32 blue_gem = 6;
  bool has_blue_gem() const;
  void clear_blue_gem();
  static const int kBlueGemFieldNumber = 6;
  ::google::protobuf::uint32 blue_gem() const;
  void set_blue_gem(::google::protobuf::uint32 value);

  // optional uint32 red_crystal = 7;
  bool has_red_crystal() const;
  void clear_red_crystal();
  static const int kRedCrystalFieldNumber = 7;
  ::google::protobuf::uint32 red_crystal() const;
  void set_red_crystal(::google::protobuf::uint32 value);

  // optional uint32 blue_crystal = 8;
  bool has_blue_crystal() const;
  void clear_blue_crystal();
  static const int kBlueCrystalFieldNumber = 8;
  ::google::protobuf::uint32 blue_crystal() const;
  void set_blue_crystal(::google::protobuf::uint32 value);

  // optional uint32 red_grail = 9;
  bool has_red_grail() const;
  void clear_red_grail();
  static const int kRedGrailFieldNumber = 9;
  ::google::protobuf::uint32 red_grail() const;
  void set_red_grail(::google::protobuf::uint32 value);

  // optional uint32 blue_grail = 10;
  bool has_blue_grail() const;
  void clear_blue_grail();
  static const int kBlueGrailFieldNumber = 10;
  ::google::protobuf::uint32 blue_grail() const;
  void set_blue_grail(::google::protobuf::uint32 value);

  // optional uint32 pile = 11;
  bool has_pile() const;
  void clear_pile();
  static const int kPileFieldNumber = 11;
  ::google::protobuf::uint32 pile() const;
  void set_pile(::google::protobuf::uint32 value);

  // optional uint32 discard = 12;
  bool has_discard() const;
  void clear_discard();
  static const int kDiscardFieldNumber = 12;
  ::google::protobuf::uint32 discard() const;
  void set_discard(::google::protobuf::uint32 value);

  // repeated .network.SinglePlayerInfo player_infos = 13;
  int player_infos_size() const;
  void clear_player_infos();
  static const int kPlayerInfosFieldNumber = 13;
  const ::network::SinglePlayerInfo& player_infos(int index) const;
  ::network::SinglePlayerInfo* mutable_player_infos(int index);
  ::network::SinglePlayerInfo* add_player_infos();
  ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >*
      mutable_player_infos();
  const ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >&
      player_infos() const;

  // @@protoc_insertion_point(class_scope:network.GameInfo)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_red_morale();
  inline void clear_has_red_morale();
  inline void set_has_blue_morale();
  inline void clear_has_blue_morale();
  inline void set_has_red_gem();
  inline void clear_has_red_gem();
  inline void set_has_blue_gem();
  inline void clear_has_blue_gem();
  inline void set_has_red_crystal();
  inline void clear_has_red_crystal();
  inline void set_has_blue_crystal();
  inline void clear_has_blue_crystal();
  inline void set_has_red_grail();
  inline void clear_has_red_grail();
  inline void set_has_blue_grail();
  inline void clear_has_blue_grail();
  inline void set_has_pile();
  inline void clear_has_pile();
  inline void set_has_discard();
  inline void clear_has_discard();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 room_id_;
  ::google::protobuf::int32 player_id_;
  ::google::protobuf::uint32 red_morale_;
  ::google::protobuf::uint32 blue_morale_;
  ::google::protobuf::uint32 red_gem_;
  ::google::protobuf::uint32 blue_gem_;
  ::google::protobuf::uint32 red_crystal_;
  ::google::protobuf::uint32 blue_crystal_;
  ::google::protobuf::uint32 red_grail_;
  ::google::protobuf::uint32 blue_grail_;
  ::google::protobuf::uint32 pile_;
  ::google::protobuf::uint32 discard_;
  ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo > player_infos_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class Talk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.Talk) */ {
 public:
  Talk();
  virtual ~Talk();

  Talk(const Talk& from);

  inline Talk& operator=(const Talk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Talk& default_instance();

  void Swap(Talk* other);

  // implements Message ----------------------------------------------

  inline Talk* New() const { return New(NULL); }

  Talk* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Talk& from);
  void MergeFrom(const Talk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Talk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string txt = 1;
  bool has_txt() const;
  void clear_txt();
  static const int kTxtFieldNumber = 1;
  const ::std::string& txt() const;
  void set_txt(const ::std::string& value);
  void set_txt(const char* value);
  void set_txt(const char* value, size_t size);
  ::std::string* mutable_txt();
  ::std::string* release_txt();
  void set_allocated_txt(::std::string* txt);

  // @@protoc_insertion_point(class_scope:network.Talk)
 private:
  inline void set_has_txt();
  inline void clear_has_txt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr txt_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static Talk* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  void Swap(Error* other);

  // implements Message ----------------------------------------------

  inline Error* New() const { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 dst_id = 2;
  bool has_dst_id() const;
  void clear_dst_id();
  static const int kDstIdFieldNumber = 2;
  ::google::protobuf::int32 dst_id() const;
  void set_dst_id(::google::protobuf::int32 value);

  // repeated int32 args = 3;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 3;
  ::google::protobuf::int32 args(int index) const;
  void set_args(int index, ::google::protobuf::int32 value);
  void add_args(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      args() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_args();

  // @@protoc_insertion_point(class_scope:network.Error)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_dst_id();
  inline void clear_has_dst_id();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 dst_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > args_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class Gossip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.Gossip) */ {
 public:
  Gossip();
  virtual ~Gossip();

  Gossip(const Gossip& from);

  inline Gossip& operator=(const Gossip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gossip& default_instance();

  void Swap(Gossip* other);

  // implements Message ----------------------------------------------

  inline Gossip* New() const { return New(NULL); }

  Gossip* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Gossip& from);
  void MergeFrom(const Gossip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Gossip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .network.GossipType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::network::GossipType type() const;
  void set_type(::network::GossipType value);

  // optional string txt = 2;
  bool has_txt() const;
  void clear_txt();
  static const int kTxtFieldNumber = 2;
  const ::std::string& txt() const;
  void set_txt(const ::std::string& value);
  void set_txt(const char* value);
  void set_txt(const char* value, size_t size);
  ::std::string* mutable_txt();
  ::std::string* release_txt();
  void set_allocated_txt(::std::string* txt);

  // optional uint32 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:network.Gossip)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_txt();
  inline void clear_has_txt();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr txt_;
  int type_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static Gossip* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.HeartBeat) */ {
 public:
  HeartBeat();
  virtual ~HeartBeat();

  HeartBeat(const HeartBeat& from);

  inline HeartBeat& operator=(const HeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeat& default_instance();

  void Swap(HeartBeat* other);

  // implements Message ----------------------------------------------

  inline HeartBeat* New() const { return New(NULL); }

  HeartBeat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeat& from);
  void MergeFrom(const HeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartBeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:network.HeartBeat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static HeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class PollingRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.PollingRequest) */ {
 public:
  PollingRequest();
  virtual ~PollingRequest();

  PollingRequest(const PollingRequest& from);

  inline PollingRequest& operator=(const PollingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PollingRequest& default_instance();

  void Swap(PollingRequest* other);

  // implements Message ----------------------------------------------

  inline PollingRequest* New() const { return New(NULL); }

  PollingRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PollingRequest& from);
  void MergeFrom(const PollingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PollingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string object = 1;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 1;
  const ::std::string& object() const;
  void set_object(const ::std::string& value);
  void set_object(const char* value);
  void set_object(const char* value, size_t size);
  ::std::string* mutable_object();
  ::std::string* release_object();
  void set_allocated_object(::std::string* object);

  // repeated string options = 2;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  const ::std::string& options(int index) const;
  ::std::string* mutable_options(int index);
  void set_options(int index, const ::std::string& value);
  void set_options(int index, const char* value);
  void set_options(int index, const char* value, size_t size);
  ::std::string* add_options();
  void add_options(const ::std::string& value);
  void add_options(const char* value);
  void add_options(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& options() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_options();

  // @@protoc_insertion_point(class_scope:network.PollingRequest)
 private:
  inline void set_has_object();
  inline void clear_has_object();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr object_;
  ::google::protobuf::RepeatedPtrField< ::std::string> options_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static PollingRequest* default_instance_;
};
// -------------------------------------------------------------------

class PollingResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:network.PollingResponse) */ {
 public:
  PollingResponse();
  virtual ~PollingResponse();

  PollingResponse(const PollingResponse& from);

  inline PollingResponse& operator=(const PollingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PollingResponse& default_instance();

  void Swap(PollingResponse* other);

  // implements Message ----------------------------------------------

  inline PollingResponse* New() const { return New(NULL); }

  PollingResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PollingResponse& from);
  void MergeFrom(const PollingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PollingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 option = 1;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::uint32 option() const;
  void set_option(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:network.PollingResponse)
 private:
  inline void set_has_option();
  inline void clear_has_option();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 option_;
  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static PollingResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterRequest

// optional string user_id = 1;
inline bool RegisterRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRequest::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& RegisterRequest::user_id() const {
  // @@protoc_insertion_point(field_get:network.RegisterRequest.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.RegisterRequest.user_id)
}
inline void RegisterRequest::set_user_id(const char* value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.RegisterRequest.user_id)
}
inline void RegisterRequest::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.RegisterRequest.user_id)
}
inline ::std::string* RegisterRequest::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:network.RegisterRequest.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:network.RegisterRequest.user_id)
  clear_has_user_id();
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:network.RegisterRequest.user_id)
}

// optional string user_password = 2;
inline bool RegisterRequest::has_user_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRequest::set_has_user_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRequest::clear_has_user_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRequest::clear_user_password() {
  user_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_password();
}
inline const ::std::string& RegisterRequest::user_password() const {
  // @@protoc_insertion_point(field_get:network.RegisterRequest.user_password)
  return user_password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_user_password(const ::std::string& value) {
  set_has_user_password();
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.RegisterRequest.user_password)
}
inline void RegisterRequest::set_user_password(const char* value) {
  set_has_user_password();
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.RegisterRequest.user_password)
}
inline void RegisterRequest::set_user_password(const char* value, size_t size) {
  set_has_user_password();
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.RegisterRequest.user_password)
}
inline ::std::string* RegisterRequest::mutable_user_password() {
  set_has_user_password();
  // @@protoc_insertion_point(field_mutable:network.RegisterRequest.user_password)
  return user_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_user_password() {
  // @@protoc_insertion_point(field_release:network.RegisterRequest.user_password)
  clear_has_user_password();
  return user_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_user_password(::std::string* user_password) {
  if (user_password != NULL) {
    set_has_user_password();
  } else {
    clear_has_user_password();
  }
  user_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_password);
  // @@protoc_insertion_point(field_set_allocated:network.RegisterRequest.user_password)
}

// optional string nickname = 3;
inline bool RegisterRequest::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterRequest::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterRequest::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterRequest::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& RegisterRequest::nickname() const {
  // @@protoc_insertion_point(field_get:network.RegisterRequest.nickname)
  return nickname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.RegisterRequest.nickname)
}
inline void RegisterRequest::set_nickname(const char* value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.RegisterRequest.nickname)
}
inline void RegisterRequest::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.RegisterRequest.nickname)
}
inline ::std::string* RegisterRequest::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:network.RegisterRequest.nickname)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_nickname() {
  // @@protoc_insertion_point(field_release:network.RegisterRequest.nickname)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:network.RegisterRequest.nickname)
}

// optional string mobile = 4;
inline bool RegisterRequest::has_mobile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterRequest::set_has_mobile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterRequest::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterRequest::clear_mobile() {
  mobile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mobile();
}
inline const ::std::string& RegisterRequest::mobile() const {
  // @@protoc_insertion_point(field_get:network.RegisterRequest.mobile)
  return mobile_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_mobile(const ::std::string& value) {
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.RegisterRequest.mobile)
}
inline void RegisterRequest::set_mobile(const char* value) {
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.RegisterRequest.mobile)
}
inline void RegisterRequest::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.RegisterRequest.mobile)
}
inline ::std::string* RegisterRequest::mutable_mobile() {
  set_has_mobile();
  // @@protoc_insertion_point(field_mutable:network.RegisterRequest.mobile)
  return mobile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_mobile() {
  // @@protoc_insertion_point(field_release:network.RegisterRequest.mobile)
  clear_has_mobile();
  return mobile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_mobile(::std::string* mobile) {
  if (mobile != NULL) {
    set_has_mobile();
  } else {
    clear_has_mobile();
  }
  mobile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mobile);
  // @@protoc_insertion_point(field_set_allocated:network.RegisterRequest.mobile)
}

// optional string email = 5;
inline bool RegisterRequest::has_email() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterRequest::set_has_email() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterRequest::clear_has_email() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterRequest::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_email();
}
inline const ::std::string& RegisterRequest::email() const {
  // @@protoc_insertion_point(field_get:network.RegisterRequest.email)
  return email_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_email(const ::std::string& value) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.RegisterRequest.email)
}
inline void RegisterRequest::set_email(const char* value) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.RegisterRequest.email)
}
inline void RegisterRequest::set_email(const char* value, size_t size) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.RegisterRequest.email)
}
inline ::std::string* RegisterRequest::mutable_email() {
  set_has_email();
  // @@protoc_insertion_point(field_mutable:network.RegisterRequest.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_email() {
  // @@protoc_insertion_point(field_release:network.RegisterRequest.email)
  clear_has_email();
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:network.RegisterRequest.email)
}

// -------------------------------------------------------------------

// RegisterResponse

// optional uint32 state = 1;
inline bool RegisterResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterResponse::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 RegisterResponse::state() const {
  // @@protoc_insertion_point(field_get:network.RegisterResponse.state)
  return state_;
}
inline void RegisterResponse::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:network.RegisterResponse.state)
}

// -------------------------------------------------------------------

// LoginRequest

// required bool asGuest = 1;
inline bool LoginRequest::has_asguest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_asguest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_asguest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_asguest() {
  asguest_ = false;
  clear_has_asguest();
}
inline bool LoginRequest::asguest() const {
  // @@protoc_insertion_point(field_get:network.LoginRequest.asGuest)
  return asguest_;
}
inline void LoginRequest::set_asguest(bool value) {
  set_has_asguest();
  asguest_ = value;
  // @@protoc_insertion_point(field_set:network.LoginRequest.asGuest)
}

// optional string user_id = 2;
inline bool LoginRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& LoginRequest::user_id() const {
  // @@protoc_insertion_point(field_get:network.LoginRequest.user_id)
  return user_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.LoginRequest.user_id)
}
inline void LoginRequest::set_user_id(const char* value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.LoginRequest.user_id)
}
inline void LoginRequest::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.LoginRequest.user_id)
}
inline ::std::string* LoginRequest::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:network.LoginRequest.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_user_id() {
  // @@protoc_insertion_point(field_release:network.LoginRequest.user_id)
  clear_has_user_id();
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:network.LoginRequest.user_id)
}

// optional string user_password = 3;
inline bool LoginRequest::has_user_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_user_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_user_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_user_password() {
  user_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_password();
}
inline const ::std::string& LoginRequest::user_password() const {
  // @@protoc_insertion_point(field_get:network.LoginRequest.user_password)
  return user_password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_user_password(const ::std::string& value) {
  set_has_user_password();
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.LoginRequest.user_password)
}
inline void LoginRequest::set_user_password(const char* value) {
  set_has_user_password();
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.LoginRequest.user_password)
}
inline void LoginRequest::set_user_password(const char* value, size_t size) {
  set_has_user_password();
  user_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.LoginRequest.user_password)
}
inline ::std::string* LoginRequest::mutable_user_password() {
  set_has_user_password();
  // @@protoc_insertion_point(field_mutable:network.LoginRequest.user_password)
  return user_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_user_password() {
  // @@protoc_insertion_point(field_release:network.LoginRequest.user_password)
  clear_has_user_password();
  return user_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_user_password(::std::string* user_password) {
  if (user_password != NULL) {
    set_has_user_password();
  } else {
    clear_has_user_password();
  }
  user_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_password);
  // @@protoc_insertion_point(field_set_allocated:network.LoginRequest.user_password)
}

// optional int32 version = 4 [default = -1];
inline bool LoginRequest::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_version() {
  version_ = -1;
  clear_has_version();
}
inline ::google::protobuf::int32 LoginRequest::version() const {
  // @@protoc_insertion_point(field_get:network.LoginRequest.version)
  return version_;
}
inline void LoginRequest::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:network.LoginRequest.version)
}

// -------------------------------------------------------------------

// LoginResponse

// required int32 state = 1;
inline bool LoginResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 LoginResponse::state() const {
  // @@protoc_insertion_point(field_get:network.LoginResponse.state)
  return state_;
}
inline void LoginResponse::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:network.LoginResponse.state)
}

// optional string nickname = 2;
inline bool LoginResponse::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& LoginResponse::nickname() const {
  // @@protoc_insertion_point(field_get:network.LoginResponse.nickname)
  return nickname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.LoginResponse.nickname)
}
inline void LoginResponse::set_nickname(const char* value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.LoginResponse.nickname)
}
inline void LoginResponse::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.LoginResponse.nickname)
}
inline ::std::string* LoginResponse::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:network.LoginResponse.nickname)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse::release_nickname() {
  // @@protoc_insertion_point(field_release:network.LoginResponse.nickname)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:network.LoginResponse.nickname)
}

// -------------------------------------------------------------------

// LogoutRequest

// -------------------------------------------------------------------

// LogoutResponse

// repeated uint32 args = 1;
inline int LogoutResponse::args_size() const {
  return args_.size();
}
inline void LogoutResponse::clear_args() {
  args_.Clear();
}
inline ::google::protobuf::uint32 LogoutResponse::args(int index) const {
  // @@protoc_insertion_point(field_get:network.LogoutResponse.args)
  return args_.Get(index);
}
inline void LogoutResponse::set_args(int index, ::google::protobuf::uint32 value) {
  args_.Set(index, value);
  // @@protoc_insertion_point(field_set:network.LogoutResponse.args)
}
inline void LogoutResponse::add_args(::google::protobuf::uint32 value) {
  args_.Add(value);
  // @@protoc_insertion_point(field_add:network.LogoutResponse.args)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
LogoutResponse::args() const {
  // @@protoc_insertion_point(field_list:network.LogoutResponse.args)
  return args_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
LogoutResponse::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:network.LogoutResponse.args)
  return &args_;
}

// -------------------------------------------------------------------

// RoomListRequest

// required .network.ROLE_STRATEGY role_strategy = 1;
inline bool RoomListRequest::has_role_strategy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomListRequest::set_has_role_strategy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomListRequest::clear_has_role_strategy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomListRequest::clear_role_strategy() {
  role_strategy_ = 1;
  clear_has_role_strategy();
}
inline ::network::ROLE_STRATEGY RoomListRequest::role_strategy() const {
  // @@protoc_insertion_point(field_get:network.RoomListRequest.role_strategy)
  return static_cast< ::network::ROLE_STRATEGY >(role_strategy_);
}
inline void RoomListRequest::set_role_strategy(::network::ROLE_STRATEGY value) {
  assert(::network::ROLE_STRATEGY_IsValid(value));
  set_has_role_strategy();
  role_strategy_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListRequest.role_strategy)
}

// -------------------------------------------------------------------

// RoomListResponse_RoomInfo

// optional int32 room_id = 1;
inline bool RoomListResponse_RoomInfo::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomListResponse_RoomInfo::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomListResponse_RoomInfo::clear_room_id() {
  room_id_ = 0;
  clear_has_room_id();
}
inline ::google::protobuf::int32 RoomListResponse_RoomInfo::room_id() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.room_id)
  return room_id_;
}
inline void RoomListResponse_RoomInfo::set_room_id(::google::protobuf::int32 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.room_id)
}

// optional string room_name = 2;
inline bool RoomListResponse_RoomInfo::has_room_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_room_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomListResponse_RoomInfo::clear_has_room_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomListResponse_RoomInfo::clear_room_name() {
  room_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_room_name();
}
inline const ::std::string& RoomListResponse_RoomInfo::room_name() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.room_name)
  return room_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomListResponse_RoomInfo::set_room_name(const ::std::string& value) {
  set_has_room_name();
  room_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.room_name)
}
inline void RoomListResponse_RoomInfo::set_room_name(const char* value) {
  set_has_room_name();
  room_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.RoomListResponse.RoomInfo.room_name)
}
inline void RoomListResponse_RoomInfo::set_room_name(const char* value, size_t size) {
  set_has_room_name();
  room_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.RoomListResponse.RoomInfo.room_name)
}
inline ::std::string* RoomListResponse_RoomInfo::mutable_room_name() {
  set_has_room_name();
  // @@protoc_insertion_point(field_mutable:network.RoomListResponse.RoomInfo.room_name)
  return room_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomListResponse_RoomInfo::release_room_name() {
  // @@protoc_insertion_point(field_release:network.RoomListResponse.RoomInfo.room_name)
  clear_has_room_name();
  return room_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomListResponse_RoomInfo::set_allocated_room_name(::std::string* room_name) {
  if (room_name != NULL) {
    set_has_room_name();
  } else {
    clear_has_room_name();
  }
  room_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), room_name);
  // @@protoc_insertion_point(field_set_allocated:network.RoomListResponse.RoomInfo.room_name)
}

// optional int32 max_player = 3;
inline bool RoomListResponse_RoomInfo::has_max_player() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_max_player() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomListResponse_RoomInfo::clear_has_max_player() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomListResponse_RoomInfo::clear_max_player() {
  max_player_ = 0;
  clear_has_max_player();
}
inline ::google::protobuf::int32 RoomListResponse_RoomInfo::max_player() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.max_player)
  return max_player_;
}
inline void RoomListResponse_RoomInfo::set_max_player(::google::protobuf::int32 value) {
  set_has_max_player();
  max_player_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.max_player)
}

// optional int32 now_player = 4;
inline bool RoomListResponse_RoomInfo::has_now_player() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_now_player() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomListResponse_RoomInfo::clear_has_now_player() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomListResponse_RoomInfo::clear_now_player() {
  now_player_ = 0;
  clear_has_now_player();
}
inline ::google::protobuf::int32 RoomListResponse_RoomInfo::now_player() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.now_player)
  return now_player_;
}
inline void RoomListResponse_RoomInfo::set_now_player(::google::protobuf::int32 value) {
  set_has_now_player();
  now_player_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.now_player)
}

// optional .network.ROLE_STRATEGY role_strategy = 5;
inline bool RoomListResponse_RoomInfo::has_role_strategy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_role_strategy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomListResponse_RoomInfo::clear_has_role_strategy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomListResponse_RoomInfo::clear_role_strategy() {
  role_strategy_ = 1;
  clear_has_role_strategy();
}
inline ::network::ROLE_STRATEGY RoomListResponse_RoomInfo::role_strategy() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.role_strategy)
  return static_cast< ::network::ROLE_STRATEGY >(role_strategy_);
}
inline void RoomListResponse_RoomInfo::set_role_strategy(::network::ROLE_STRATEGY value) {
  assert(::network::ROLE_STRATEGY_IsValid(value));
  set_has_role_strategy();
  role_strategy_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.role_strategy)
}

// optional int32 seat_mode = 6;
inline bool RoomListResponse_RoomInfo::has_seat_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_seat_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomListResponse_RoomInfo::clear_has_seat_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomListResponse_RoomInfo::clear_seat_mode() {
  seat_mode_ = 0;
  clear_has_seat_mode();
}
inline ::google::protobuf::int32 RoomListResponse_RoomInfo::seat_mode() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.seat_mode)
  return seat_mode_;
}
inline void RoomListResponse_RoomInfo::set_seat_mode(::google::protobuf::int32 value) {
  set_has_seat_mode();
  seat_mode_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.seat_mode)
}

// optional int32 role_range = 7;
inline bool RoomListResponse_RoomInfo::has_role_range() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_role_range() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomListResponse_RoomInfo::clear_has_role_range() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomListResponse_RoomInfo::clear_role_range() {
  role_range_ = 0;
  clear_has_role_range();
}
inline ::google::protobuf::int32 RoomListResponse_RoomInfo::role_range() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.role_range)
  return role_range_;
}
inline void RoomListResponse_RoomInfo::set_role_range(::google::protobuf::int32 value) {
  set_has_role_range();
  role_range_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.role_range)
}

// optional bool allow_guest = 8 [default = true];
inline bool RoomListResponse_RoomInfo::has_allow_guest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_allow_guest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomListResponse_RoomInfo::clear_has_allow_guest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomListResponse_RoomInfo::clear_allow_guest() {
  allow_guest_ = true;
  clear_has_allow_guest();
}
inline bool RoomListResponse_RoomInfo::allow_guest() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.allow_guest)
  return allow_guest_;
}
inline void RoomListResponse_RoomInfo::set_allow_guest(bool value) {
  set_has_allow_guest();
  allow_guest_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.allow_guest)
}

// optional bool has_password = 9 [default = false];
inline bool RoomListResponse_RoomInfo::has_has_password() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_has_password() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomListResponse_RoomInfo::clear_has_has_password() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomListResponse_RoomInfo::clear_has_password() {
  has_password_ = false;
  clear_has_has_password();
}
inline bool RoomListResponse_RoomInfo::has_password() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.has_password)
  return has_password_;
}
inline void RoomListResponse_RoomInfo::set_has_password(bool value) {
  set_has_has_password();
  has_password_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.has_password)
}

// optional bool first_extension = 10;
inline bool RoomListResponse_RoomInfo::has_first_extension() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_first_extension() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RoomListResponse_RoomInfo::clear_has_first_extension() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RoomListResponse_RoomInfo::clear_first_extension() {
  first_extension_ = false;
  clear_has_first_extension();
}
inline bool RoomListResponse_RoomInfo::first_extension() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.first_extension)
  return first_extension_;
}
inline void RoomListResponse_RoomInfo::set_first_extension(bool value) {
  set_has_first_extension();
  first_extension_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.first_extension)
}

// optional bool second_extension = 11;
inline bool RoomListResponse_RoomInfo::has_second_extension() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_second_extension() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RoomListResponse_RoomInfo::clear_has_second_extension() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RoomListResponse_RoomInfo::clear_second_extension() {
  second_extension_ = false;
  clear_has_second_extension();
}
inline bool RoomListResponse_RoomInfo::second_extension() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.second_extension)
  return second_extension_;
}
inline void RoomListResponse_RoomInfo::set_second_extension(bool value) {
  set_has_second_extension();
  second_extension_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.second_extension)
}

// optional bool sp_mo_dao = 12;
inline bool RoomListResponse_RoomInfo::has_sp_mo_dao() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_sp_mo_dao() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RoomListResponse_RoomInfo::clear_has_sp_mo_dao() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RoomListResponse_RoomInfo::clear_sp_mo_dao() {
  sp_mo_dao_ = false;
  clear_has_sp_mo_dao();
}
inline bool RoomListResponse_RoomInfo::sp_mo_dao() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.sp_mo_dao)
  return sp_mo_dao_;
}
inline void RoomListResponse_RoomInfo::set_sp_mo_dao(bool value) {
  set_has_sp_mo_dao();
  sp_mo_dao_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.sp_mo_dao)
}

// optional bool playing = 13 [default = false];
inline bool RoomListResponse_RoomInfo::has_playing() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_playing() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RoomListResponse_RoomInfo::clear_has_playing() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RoomListResponse_RoomInfo::clear_playing() {
  playing_ = false;
  clear_has_playing();
}
inline bool RoomListResponse_RoomInfo::playing() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.playing)
  return playing_;
}
inline void RoomListResponse_RoomInfo::set_playing(bool value) {
  set_has_playing();
  playing_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.playing)
}

// optional bool silence = 14 [default = false];
inline bool RoomListResponse_RoomInfo::has_silence() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RoomListResponse_RoomInfo::set_has_silence() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RoomListResponse_RoomInfo::clear_has_silence() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RoomListResponse_RoomInfo::clear_silence() {
  silence_ = false;
  clear_has_silence();
}
inline bool RoomListResponse_RoomInfo::silence() const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.RoomInfo.silence)
  return silence_;
}
inline void RoomListResponse_RoomInfo::set_silence(bool value) {
  set_has_silence();
  silence_ = value;
  // @@protoc_insertion_point(field_set:network.RoomListResponse.RoomInfo.silence)
}

// -------------------------------------------------------------------

// RoomListResponse

// repeated .network.RoomListResponse.RoomInfo rooms = 1;
inline int RoomListResponse::rooms_size() const {
  return rooms_.size();
}
inline void RoomListResponse::clear_rooms() {
  rooms_.Clear();
}
inline const ::network::RoomListResponse_RoomInfo& RoomListResponse::rooms(int index) const {
  // @@protoc_insertion_point(field_get:network.RoomListResponse.rooms)
  return rooms_.Get(index);
}
inline ::network::RoomListResponse_RoomInfo* RoomListResponse::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:network.RoomListResponse.rooms)
  return rooms_.Mutable(index);
}
inline ::network::RoomListResponse_RoomInfo* RoomListResponse::add_rooms() {
  // @@protoc_insertion_point(field_add:network.RoomListResponse.rooms)
  return rooms_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::network::RoomListResponse_RoomInfo >*
RoomListResponse::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:network.RoomListResponse.rooms)
  return &rooms_;
}
inline const ::google::protobuf::RepeatedPtrField< ::network::RoomListResponse_RoomInfo >&
RoomListResponse::rooms() const {
  // @@protoc_insertion_point(field_list:network.RoomListResponse.rooms)
  return rooms_;
}

// -------------------------------------------------------------------

// CreateRoomRequest

// optional string room_name = 1;
inline bool CreateRoomRequest::has_room_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomRequest::set_has_room_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomRequest::clear_has_room_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomRequest::clear_room_name() {
  room_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_room_name();
}
inline const ::std::string& CreateRoomRequest::room_name() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.room_name)
  return room_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomRequest::set_room_name(const ::std::string& value) {
  set_has_room_name();
  room_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.CreateRoomRequest.room_name)
}
inline void CreateRoomRequest::set_room_name(const char* value) {
  set_has_room_name();
  room_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.CreateRoomRequest.room_name)
}
inline void CreateRoomRequest::set_room_name(const char* value, size_t size) {
  set_has_room_name();
  room_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.CreateRoomRequest.room_name)
}
inline ::std::string* CreateRoomRequest::mutable_room_name() {
  set_has_room_name();
  // @@protoc_insertion_point(field_mutable:network.CreateRoomRequest.room_name)
  return room_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoomRequest::release_room_name() {
  // @@protoc_insertion_point(field_release:network.CreateRoomRequest.room_name)
  clear_has_room_name();
  return room_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomRequest::set_allocated_room_name(::std::string* room_name) {
  if (room_name != NULL) {
    set_has_room_name();
  } else {
    clear_has_room_name();
  }
  room_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), room_name);
  // @@protoc_insertion_point(field_set_allocated:network.CreateRoomRequest.room_name)
}

// optional int32 max_player = 2;
inline bool CreateRoomRequest::has_max_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomRequest::set_has_max_player() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomRequest::clear_has_max_player() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomRequest::clear_max_player() {
  max_player_ = 0;
  clear_has_max_player();
}
inline ::google::protobuf::int32 CreateRoomRequest::max_player() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.max_player)
  return max_player_;
}
inline void CreateRoomRequest::set_max_player(::google::protobuf::int32 value) {
  set_has_max_player();
  max_player_ = value;
  // @@protoc_insertion_point(field_set:network.CreateRoomRequest.max_player)
}

// optional .network.ROLE_STRATEGY role_strategy = 3;
inline bool CreateRoomRequest::has_role_strategy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoomRequest::set_has_role_strategy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoomRequest::clear_has_role_strategy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoomRequest::clear_role_strategy() {
  role_strategy_ = 1;
  clear_has_role_strategy();
}
inline ::network::ROLE_STRATEGY CreateRoomRequest::role_strategy() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.role_strategy)
  return static_cast< ::network::ROLE_STRATEGY >(role_strategy_);
}
inline void CreateRoomRequest::set_role_strategy(::network::ROLE_STRATEGY value) {
  assert(::network::ROLE_STRATEGY_IsValid(value));
  set_has_role_strategy();
  role_strategy_ = value;
  // @@protoc_insertion_point(field_set:network.CreateRoomRequest.role_strategy)
}

// optional bool first_extension = 4;
inline bool CreateRoomRequest::has_first_extension() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateRoomRequest::set_has_first_extension() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateRoomRequest::clear_has_first_extension() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateRoomRequest::clear_first_extension() {
  first_extension_ = false;
  clear_has_first_extension();
}
inline bool CreateRoomRequest::first_extension() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.first_extension)
  return first_extension_;
}
inline void CreateRoomRequest::set_first_extension(bool value) {
  set_has_first_extension();
  first_extension_ = value;
  // @@protoc_insertion_point(field_set:network.CreateRoomRequest.first_extension)
}

// optional bool second_extension = 5;
inline bool CreateRoomRequest::has_second_extension() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateRoomRequest::set_has_second_extension() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateRoomRequest::clear_has_second_extension() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateRoomRequest::clear_second_extension() {
  second_extension_ = false;
  clear_has_second_extension();
}
inline bool CreateRoomRequest::second_extension() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.second_extension)
  return second_extension_;
}
inline void CreateRoomRequest::set_second_extension(bool value) {
  set_has_second_extension();
  second_extension_ = value;
  // @@protoc_insertion_point(field_set:network.CreateRoomRequest.second_extension)
}

// optional bool sp_mo_dao = 6;
inline bool CreateRoomRequest::has_sp_mo_dao() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateRoomRequest::set_has_sp_mo_dao() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateRoomRequest::clear_has_sp_mo_dao() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateRoomRequest::clear_sp_mo_dao() {
  sp_mo_dao_ = false;
  clear_has_sp_mo_dao();
}
inline bool CreateRoomRequest::sp_mo_dao() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.sp_mo_dao)
  return sp_mo_dao_;
}
inline void CreateRoomRequest::set_sp_mo_dao(bool value) {
  set_has_sp_mo_dao();
  sp_mo_dao_ = value;
  // @@protoc_insertion_point(field_set:network.CreateRoomRequest.sp_mo_dao)
}

// optional int32 seat_mode = 7;
inline bool CreateRoomRequest::has_seat_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateRoomRequest::set_has_seat_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateRoomRequest::clear_has_seat_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateRoomRequest::clear_seat_mode() {
  seat_mode_ = 0;
  clear_has_seat_mode();
}
inline ::google::protobuf::int32 CreateRoomRequest::seat_mode() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.seat_mode)
  return seat_mode_;
}
inline void CreateRoomRequest::set_seat_mode(::google::protobuf::int32 value) {
  set_has_seat_mode();
  seat_mode_ = value;
  // @@protoc_insertion_point(field_set:network.CreateRoomRequest.seat_mode)
}

// optional bool allow_guest = 8 [default = true];
inline bool CreateRoomRequest::has_allow_guest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateRoomRequest::set_has_allow_guest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateRoomRequest::clear_has_allow_guest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateRoomRequest::clear_allow_guest() {
  allow_guest_ = true;
  clear_has_allow_guest();
}
inline bool CreateRoomRequest::allow_guest() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.allow_guest)
  return allow_guest_;
}
inline void CreateRoomRequest::set_allow_guest(bool value) {
  set_has_allow_guest();
  allow_guest_ = value;
  // @@protoc_insertion_point(field_set:network.CreateRoomRequest.allow_guest)
}

// optional string password = 9 [default = ""];
inline bool CreateRoomRequest::has_password() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CreateRoomRequest::set_has_password() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CreateRoomRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CreateRoomRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& CreateRoomRequest::password() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.CreateRoomRequest.password)
}
inline void CreateRoomRequest::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.CreateRoomRequest.password)
}
inline void CreateRoomRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.CreateRoomRequest.password)
}
inline ::std::string* CreateRoomRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:network.CreateRoomRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoomRequest::release_password() {
  // @@protoc_insertion_point(field_release:network.CreateRoomRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:network.CreateRoomRequest.password)
}

// optional bool silence = 10 [default = false];
inline bool CreateRoomRequest::has_silence() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CreateRoomRequest::set_has_silence() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CreateRoomRequest::clear_has_silence() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CreateRoomRequest::clear_silence() {
  silence_ = false;
  clear_has_silence();
}
inline bool CreateRoomRequest::silence() const {
  // @@protoc_insertion_point(field_get:network.CreateRoomRequest.silence)
  return silence_;
}
inline void CreateRoomRequest::set_silence(bool value) {
  set_has_silence();
  silence_ = value;
  // @@protoc_insertion_point(field_set:network.CreateRoomRequest.silence)
}

// -------------------------------------------------------------------

// EnterRoomRequest

// required int32 room_id = 1;
inline bool EnterRoomRequest::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomRequest::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomRequest::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomRequest::clear_room_id() {
  room_id_ = 0;
  clear_has_room_id();
}
inline ::google::protobuf::int32 EnterRoomRequest::room_id() const {
  // @@protoc_insertion_point(field_get:network.EnterRoomRequest.room_id)
  return room_id_;
}
inline void EnterRoomRequest::set_room_id(::google::protobuf::int32 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:network.EnterRoomRequest.room_id)
}

// optional string password = 2;
inline bool EnterRoomRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& EnterRoomRequest::password() const {
  // @@protoc_insertion_point(field_get:network.EnterRoomRequest.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnterRoomRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.EnterRoomRequest.password)
}
inline void EnterRoomRequest::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.EnterRoomRequest.password)
}
inline void EnterRoomRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.EnterRoomRequest.password)
}
inline ::std::string* EnterRoomRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:network.EnterRoomRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnterRoomRequest::release_password() {
  // @@protoc_insertion_point(field_release:network.EnterRoomRequest.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnterRoomRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:network.EnterRoomRequest.password)
}

// -------------------------------------------------------------------

// LeaveRoomRequest

// -------------------------------------------------------------------

// JoinTeamRequest

// required .network.JoinTeamRequest.Team team = 1;
inline bool JoinTeamRequest::has_team() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinTeamRequest::set_has_team() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinTeamRequest::clear_has_team() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinTeamRequest::clear_team() {
  team_ = 1;
  clear_has_team();
}
inline ::network::JoinTeamRequest_Team JoinTeamRequest::team() const {
  // @@protoc_insertion_point(field_get:network.JoinTeamRequest.team)
  return static_cast< ::network::JoinTeamRequest_Team >(team_);
}
inline void JoinTeamRequest::set_team(::network::JoinTeamRequest_Team value) {
  assert(::network::JoinTeamRequest_Team_IsValid(value));
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:network.JoinTeamRequest.team)
}

// -------------------------------------------------------------------

// BecomeLeaderRequest

// -------------------------------------------------------------------

// BecomeLeaderResponse

// optional bool yes = 1 [default = false];
inline bool BecomeLeaderResponse::has_yes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BecomeLeaderResponse::set_has_yes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BecomeLeaderResponse::clear_has_yes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BecomeLeaderResponse::clear_yes() {
  yes_ = false;
  clear_has_yes();
}
inline bool BecomeLeaderResponse::yes() const {
  // @@protoc_insertion_point(field_get:network.BecomeLeaderResponse.yes)
  return yes_;
}
inline void BecomeLeaderResponse::set_yes(bool value) {
  set_has_yes();
  yes_ = value;
  // @@protoc_insertion_point(field_set:network.BecomeLeaderResponse.yes)
}

// -------------------------------------------------------------------

// ReadyForGameRequest

// required .network.ReadyForGameRequest.Type type = 1;
inline bool ReadyForGameRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadyForGameRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadyForGameRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadyForGameRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::network::ReadyForGameRequest_Type ReadyForGameRequest::type() const {
  // @@protoc_insertion_point(field_get:network.ReadyForGameRequest.type)
  return static_cast< ::network::ReadyForGameRequest_Type >(type_);
}
inline void ReadyForGameRequest::set_type(::network::ReadyForGameRequest_Type value) {
  assert(::network::ReadyForGameRequest_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:network.ReadyForGameRequest.type)
}

// -------------------------------------------------------------------

// SinglePlayerInfo

// optional uint32 id = 1;
inline bool SinglePlayerInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SinglePlayerInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SinglePlayerInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SinglePlayerInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::id() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.id)
  return id_;
}
inline void SinglePlayerInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.id)
}

// optional uint32 team = 2;
inline bool SinglePlayerInfo::has_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SinglePlayerInfo::set_has_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SinglePlayerInfo::clear_has_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SinglePlayerInfo::clear_team() {
  team_ = 0u;
  clear_has_team();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::team() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.team)
  return team_;
}
inline void SinglePlayerInfo::set_team(::google::protobuf::uint32 value) {
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.team)
}

// optional uint32 role_id = 3;
inline bool SinglePlayerInfo::has_role_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SinglePlayerInfo::set_has_role_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SinglePlayerInfo::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SinglePlayerInfo::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::role_id() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.role_id)
  return role_id_;
}
inline void SinglePlayerInfo::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.role_id)
}

// optional uint32 hand_count = 4;
inline bool SinglePlayerInfo::has_hand_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SinglePlayerInfo::set_has_hand_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SinglePlayerInfo::clear_has_hand_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SinglePlayerInfo::clear_hand_count() {
  hand_count_ = 0u;
  clear_has_hand_count();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::hand_count() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.hand_count)
  return hand_count_;
}
inline void SinglePlayerInfo::set_hand_count(::google::protobuf::uint32 value) {
  set_has_hand_count();
  hand_count_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.hand_count)
}

// optional uint32 heal_count = 5;
inline bool SinglePlayerInfo::has_heal_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SinglePlayerInfo::set_has_heal_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SinglePlayerInfo::clear_has_heal_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SinglePlayerInfo::clear_heal_count() {
  heal_count_ = 0u;
  clear_has_heal_count();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::heal_count() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.heal_count)
  return heal_count_;
}
inline void SinglePlayerInfo::set_heal_count(::google::protobuf::uint32 value) {
  set_has_heal_count();
  heal_count_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.heal_count)
}

// repeated uint32 ex_cards = 6;
inline int SinglePlayerInfo::ex_cards_size() const {
  return ex_cards_.size();
}
inline void SinglePlayerInfo::clear_ex_cards() {
  ex_cards_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::ex_cards(int index) const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.ex_cards)
  return ex_cards_.Get(index);
}
inline void SinglePlayerInfo::set_ex_cards(int index, ::google::protobuf::uint32 value) {
  ex_cards_.Set(index, value);
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.ex_cards)
}
inline void SinglePlayerInfo::add_ex_cards(::google::protobuf::uint32 value) {
  ex_cards_.Add(value);
  // @@protoc_insertion_point(field_add:network.SinglePlayerInfo.ex_cards)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::ex_cards() const {
  // @@protoc_insertion_point(field_list:network.SinglePlayerInfo.ex_cards)
  return ex_cards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_ex_cards() {
  // @@protoc_insertion_point(field_mutable_list:network.SinglePlayerInfo.ex_cards)
  return &ex_cards_;
}

// repeated uint32 basic_cards = 7;
inline int SinglePlayerInfo::basic_cards_size() const {
  return basic_cards_.size();
}
inline void SinglePlayerInfo::clear_basic_cards() {
  basic_cards_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::basic_cards(int index) const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.basic_cards)
  return basic_cards_.Get(index);
}
inline void SinglePlayerInfo::set_basic_cards(int index, ::google::protobuf::uint32 value) {
  basic_cards_.Set(index, value);
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.basic_cards)
}
inline void SinglePlayerInfo::add_basic_cards(::google::protobuf::uint32 value) {
  basic_cards_.Add(value);
  // @@protoc_insertion_point(field_add:network.SinglePlayerInfo.basic_cards)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::basic_cards() const {
  // @@protoc_insertion_point(field_list:network.SinglePlayerInfo.basic_cards)
  return basic_cards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_basic_cards() {
  // @@protoc_insertion_point(field_mutable_list:network.SinglePlayerInfo.basic_cards)
  return &basic_cards_;
}

// optional uint32 gem = 8;
inline bool SinglePlayerInfo::has_gem() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SinglePlayerInfo::set_has_gem() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SinglePlayerInfo::clear_has_gem() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SinglePlayerInfo::clear_gem() {
  gem_ = 0u;
  clear_has_gem();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::gem() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.gem)
  return gem_;
}
inline void SinglePlayerInfo::set_gem(::google::protobuf::uint32 value) {
  set_has_gem();
  gem_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.gem)
}

// optional uint32 crystal = 9;
inline bool SinglePlayerInfo::has_crystal() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SinglePlayerInfo::set_has_crystal() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SinglePlayerInfo::clear_has_crystal() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SinglePlayerInfo::clear_crystal() {
  crystal_ = 0u;
  clear_has_crystal();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::crystal() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.crystal)
  return crystal_;
}
inline void SinglePlayerInfo::set_crystal(::google::protobuf::uint32 value) {
  set_has_crystal();
  crystal_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.crystal)
}

// optional uint32 yellow_token = 10;
inline bool SinglePlayerInfo::has_yellow_token() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SinglePlayerInfo::set_has_yellow_token() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SinglePlayerInfo::clear_has_yellow_token() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SinglePlayerInfo::clear_yellow_token() {
  yellow_token_ = 0u;
  clear_has_yellow_token();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::yellow_token() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.yellow_token)
  return yellow_token_;
}
inline void SinglePlayerInfo::set_yellow_token(::google::protobuf::uint32 value) {
  set_has_yellow_token();
  yellow_token_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.yellow_token)
}

// optional uint32 blue_token = 11;
inline bool SinglePlayerInfo::has_blue_token() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SinglePlayerInfo::set_has_blue_token() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SinglePlayerInfo::clear_has_blue_token() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SinglePlayerInfo::clear_blue_token() {
  blue_token_ = 0u;
  clear_has_blue_token();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::blue_token() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.blue_token)
  return blue_token_;
}
inline void SinglePlayerInfo::set_blue_token(::google::protobuf::uint32 value) {
  set_has_blue_token();
  blue_token_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.blue_token)
}

// optional uint32 covered_count = 12;
inline bool SinglePlayerInfo::has_covered_count() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SinglePlayerInfo::set_has_covered_count() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SinglePlayerInfo::clear_has_covered_count() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SinglePlayerInfo::clear_covered_count() {
  covered_count_ = 0u;
  clear_has_covered_count();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::covered_count() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.covered_count)
  return covered_count_;
}
inline void SinglePlayerInfo::set_covered_count(::google::protobuf::uint32 value) {
  set_has_covered_count();
  covered_count_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.covered_count)
}

// optional bool is_knelt = 13;
inline bool SinglePlayerInfo::has_is_knelt() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SinglePlayerInfo::set_has_is_knelt() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SinglePlayerInfo::clear_has_is_knelt() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SinglePlayerInfo::clear_is_knelt() {
  is_knelt_ = false;
  clear_has_is_knelt();
}
inline bool SinglePlayerInfo::is_knelt() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.is_knelt)
  return is_knelt_;
}
inline void SinglePlayerInfo::set_is_knelt(bool value) {
  set_has_is_knelt();
  is_knelt_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.is_knelt)
}

// repeated uint32 hands = 14;
inline int SinglePlayerInfo::hands_size() const {
  return hands_.size();
}
inline void SinglePlayerInfo::clear_hands() {
  hands_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::hands(int index) const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.hands)
  return hands_.Get(index);
}
inline void SinglePlayerInfo::set_hands(int index, ::google::protobuf::uint32 value) {
  hands_.Set(index, value);
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.hands)
}
inline void SinglePlayerInfo::add_hands(::google::protobuf::uint32 value) {
  hands_.Add(value);
  // @@protoc_insertion_point(field_add:network.SinglePlayerInfo.hands)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::hands() const {
  // @@protoc_insertion_point(field_list:network.SinglePlayerInfo.hands)
  return hands_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_hands() {
  // @@protoc_insertion_point(field_mutable_list:network.SinglePlayerInfo.hands)
  return &hands_;
}

// repeated uint32 covereds = 15;
inline int SinglePlayerInfo::covereds_size() const {
  return covereds_.size();
}
inline void SinglePlayerInfo::clear_covereds() {
  covereds_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::covereds(int index) const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.covereds)
  return covereds_.Get(index);
}
inline void SinglePlayerInfo::set_covereds(int index, ::google::protobuf::uint32 value) {
  covereds_.Set(index, value);
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.covereds)
}
inline void SinglePlayerInfo::add_covereds(::google::protobuf::uint32 value) {
  covereds_.Add(value);
  // @@protoc_insertion_point(field_add:network.SinglePlayerInfo.covereds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::covereds() const {
  // @@protoc_insertion_point(field_list:network.SinglePlayerInfo.covereds)
  return covereds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_covereds() {
  // @@protoc_insertion_point(field_mutable_list:network.SinglePlayerInfo.covereds)
  return &covereds_;
}

// optional uint32 max_hand = 16;
inline bool SinglePlayerInfo::has_max_hand() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SinglePlayerInfo::set_has_max_hand() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SinglePlayerInfo::clear_has_max_hand() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SinglePlayerInfo::clear_max_hand() {
  max_hand_ = 0u;
  clear_has_max_hand();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::max_hand() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.max_hand)
  return max_hand_;
}
inline void SinglePlayerInfo::set_max_hand(::google::protobuf::uint32 value) {
  set_has_max_hand();
  max_hand_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.max_hand)
}

// optional string nickname = 17;
inline bool SinglePlayerInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SinglePlayerInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SinglePlayerInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SinglePlayerInfo::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& SinglePlayerInfo::nickname() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.nickname)
  return nickname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SinglePlayerInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.nickname)
}
inline void SinglePlayerInfo::set_nickname(const char* value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.SinglePlayerInfo.nickname)
}
inline void SinglePlayerInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.SinglePlayerInfo.nickname)
}
inline ::std::string* SinglePlayerInfo::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:network.SinglePlayerInfo.nickname)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SinglePlayerInfo::release_nickname() {
  // @@protoc_insertion_point(field_release:network.SinglePlayerInfo.nickname)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SinglePlayerInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:network.SinglePlayerInfo.nickname)
}

// optional bool ready = 18 [default = false];
inline bool SinglePlayerInfo::has_ready() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SinglePlayerInfo::set_has_ready() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SinglePlayerInfo::clear_has_ready() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SinglePlayerInfo::clear_ready() {
  ready_ = false;
  clear_has_ready();
}
inline bool SinglePlayerInfo::ready() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.ready)
  return ready_;
}
inline void SinglePlayerInfo::set_ready(bool value) {
  set_has_ready();
  ready_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.ready)
}

// repeated string delete_field = 19;
inline int SinglePlayerInfo::delete_field_size() const {
  return delete_field_.size();
}
inline void SinglePlayerInfo::clear_delete_field() {
  delete_field_.Clear();
}
inline const ::std::string& SinglePlayerInfo::delete_field(int index) const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.delete_field)
  return delete_field_.Get(index);
}
inline ::std::string* SinglePlayerInfo::mutable_delete_field(int index) {
  // @@protoc_insertion_point(field_mutable:network.SinglePlayerInfo.delete_field)
  return delete_field_.Mutable(index);
}
inline void SinglePlayerInfo::set_delete_field(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.delete_field)
  delete_field_.Mutable(index)->assign(value);
}
inline void SinglePlayerInfo::set_delete_field(int index, const char* value) {
  delete_field_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:network.SinglePlayerInfo.delete_field)
}
inline void SinglePlayerInfo::set_delete_field(int index, const char* value, size_t size) {
  delete_field_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.SinglePlayerInfo.delete_field)
}
inline ::std::string* SinglePlayerInfo::add_delete_field() {
  // @@protoc_insertion_point(field_add_mutable:network.SinglePlayerInfo.delete_field)
  return delete_field_.Add();
}
inline void SinglePlayerInfo::add_delete_field(const ::std::string& value) {
  delete_field_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:network.SinglePlayerInfo.delete_field)
}
inline void SinglePlayerInfo::add_delete_field(const char* value) {
  delete_field_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:network.SinglePlayerInfo.delete_field)
}
inline void SinglePlayerInfo::add_delete_field(const char* value, size_t size) {
  delete_field_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:network.SinglePlayerInfo.delete_field)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SinglePlayerInfo::delete_field() const {
  // @@protoc_insertion_point(field_list:network.SinglePlayerInfo.delete_field)
  return delete_field_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SinglePlayerInfo::mutable_delete_field() {
  // @@protoc_insertion_point(field_mutable_list:network.SinglePlayerInfo.delete_field)
  return &delete_field_;
}

// optional uint32 leader = 20;
inline bool SinglePlayerInfo::has_leader() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SinglePlayerInfo::set_has_leader() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SinglePlayerInfo::clear_has_leader() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SinglePlayerInfo::clear_leader() {
  leader_ = 0u;
  clear_has_leader();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::leader() const {
  // @@protoc_insertion_point(field_get:network.SinglePlayerInfo.leader)
  return leader_;
}
inline void SinglePlayerInfo::set_leader(::google::protobuf::uint32 value) {
  set_has_leader();
  leader_ = value;
  // @@protoc_insertion_point(field_set:network.SinglePlayerInfo.leader)
}

// -------------------------------------------------------------------

// GameInfo

// optional int32 room_id = 1;
inline bool GameInfo::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInfo::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInfo::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInfo::clear_room_id() {
  room_id_ = 0;
  clear_has_room_id();
}
inline ::google::protobuf::int32 GameInfo::room_id() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.room_id)
  return room_id_;
}
inline void GameInfo::set_room_id(::google::protobuf::int32 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.room_id)
}

// optional int32 player_id = 2;
inline bool GameInfo::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInfo::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInfo::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInfo::clear_player_id() {
  player_id_ = 0;
  clear_has_player_id();
}
inline ::google::protobuf::int32 GameInfo::player_id() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.player_id)
  return player_id_;
}
inline void GameInfo::set_player_id(::google::protobuf::int32 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.player_id)
}

// optional uint32 red_morale = 3;
inline bool GameInfo::has_red_morale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameInfo::set_has_red_morale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameInfo::clear_has_red_morale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameInfo::clear_red_morale() {
  red_morale_ = 0u;
  clear_has_red_morale();
}
inline ::google::protobuf::uint32 GameInfo::red_morale() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.red_morale)
  return red_morale_;
}
inline void GameInfo::set_red_morale(::google::protobuf::uint32 value) {
  set_has_red_morale();
  red_morale_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.red_morale)
}

// optional uint32 blue_morale = 4;
inline bool GameInfo::has_blue_morale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameInfo::set_has_blue_morale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameInfo::clear_has_blue_morale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameInfo::clear_blue_morale() {
  blue_morale_ = 0u;
  clear_has_blue_morale();
}
inline ::google::protobuf::uint32 GameInfo::blue_morale() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.blue_morale)
  return blue_morale_;
}
inline void GameInfo::set_blue_morale(::google::protobuf::uint32 value) {
  set_has_blue_morale();
  blue_morale_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.blue_morale)
}

// optional uint32 red_gem = 5;
inline bool GameInfo::has_red_gem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameInfo::set_has_red_gem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameInfo::clear_has_red_gem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameInfo::clear_red_gem() {
  red_gem_ = 0u;
  clear_has_red_gem();
}
inline ::google::protobuf::uint32 GameInfo::red_gem() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.red_gem)
  return red_gem_;
}
inline void GameInfo::set_red_gem(::google::protobuf::uint32 value) {
  set_has_red_gem();
  red_gem_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.red_gem)
}

// optional uint32 blue_gem = 6;
inline bool GameInfo::has_blue_gem() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameInfo::set_has_blue_gem() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameInfo::clear_has_blue_gem() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameInfo::clear_blue_gem() {
  blue_gem_ = 0u;
  clear_has_blue_gem();
}
inline ::google::protobuf::uint32 GameInfo::blue_gem() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.blue_gem)
  return blue_gem_;
}
inline void GameInfo::set_blue_gem(::google::protobuf::uint32 value) {
  set_has_blue_gem();
  blue_gem_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.blue_gem)
}

// optional uint32 red_crystal = 7;
inline bool GameInfo::has_red_crystal() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameInfo::set_has_red_crystal() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameInfo::clear_has_red_crystal() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameInfo::clear_red_crystal() {
  red_crystal_ = 0u;
  clear_has_red_crystal();
}
inline ::google::protobuf::uint32 GameInfo::red_crystal() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.red_crystal)
  return red_crystal_;
}
inline void GameInfo::set_red_crystal(::google::protobuf::uint32 value) {
  set_has_red_crystal();
  red_crystal_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.red_crystal)
}

// optional uint32 blue_crystal = 8;
inline bool GameInfo::has_blue_crystal() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameInfo::set_has_blue_crystal() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameInfo::clear_has_blue_crystal() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameInfo::clear_blue_crystal() {
  blue_crystal_ = 0u;
  clear_has_blue_crystal();
}
inline ::google::protobuf::uint32 GameInfo::blue_crystal() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.blue_crystal)
  return blue_crystal_;
}
inline void GameInfo::set_blue_crystal(::google::protobuf::uint32 value) {
  set_has_blue_crystal();
  blue_crystal_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.blue_crystal)
}

// optional uint32 red_grail = 9;
inline bool GameInfo::has_red_grail() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameInfo::set_has_red_grail() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameInfo::clear_has_red_grail() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameInfo::clear_red_grail() {
  red_grail_ = 0u;
  clear_has_red_grail();
}
inline ::google::protobuf::uint32 GameInfo::red_grail() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.red_grail)
  return red_grail_;
}
inline void GameInfo::set_red_grail(::google::protobuf::uint32 value) {
  set_has_red_grail();
  red_grail_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.red_grail)
}

// optional uint32 blue_grail = 10;
inline bool GameInfo::has_blue_grail() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameInfo::set_has_blue_grail() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameInfo::clear_has_blue_grail() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameInfo::clear_blue_grail() {
  blue_grail_ = 0u;
  clear_has_blue_grail();
}
inline ::google::protobuf::uint32 GameInfo::blue_grail() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.blue_grail)
  return blue_grail_;
}
inline void GameInfo::set_blue_grail(::google::protobuf::uint32 value) {
  set_has_blue_grail();
  blue_grail_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.blue_grail)
}

// optional uint32 pile = 11;
inline bool GameInfo::has_pile() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameInfo::set_has_pile() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameInfo::clear_has_pile() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameInfo::clear_pile() {
  pile_ = 0u;
  clear_has_pile();
}
inline ::google::protobuf::uint32 GameInfo::pile() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.pile)
  return pile_;
}
inline void GameInfo::set_pile(::google::protobuf::uint32 value) {
  set_has_pile();
  pile_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.pile)
}

// optional uint32 discard = 12;
inline bool GameInfo::has_discard() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameInfo::set_has_discard() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameInfo::clear_has_discard() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameInfo::clear_discard() {
  discard_ = 0u;
  clear_has_discard();
}
inline ::google::protobuf::uint32 GameInfo::discard() const {
  // @@protoc_insertion_point(field_get:network.GameInfo.discard)
  return discard_;
}
inline void GameInfo::set_discard(::google::protobuf::uint32 value) {
  set_has_discard();
  discard_ = value;
  // @@protoc_insertion_point(field_set:network.GameInfo.discard)
}

// repeated .network.SinglePlayerInfo player_infos = 13;
inline int GameInfo::player_infos_size() const {
  return player_infos_.size();
}
inline void GameInfo::clear_player_infos() {
  player_infos_.Clear();
}
inline const ::network::SinglePlayerInfo& GameInfo::player_infos(int index) const {
  // @@protoc_insertion_point(field_get:network.GameInfo.player_infos)
  return player_infos_.Get(index);
}
inline ::network::SinglePlayerInfo* GameInfo::mutable_player_infos(int index) {
  // @@protoc_insertion_point(field_mutable:network.GameInfo.player_infos)
  return player_infos_.Mutable(index);
}
inline ::network::SinglePlayerInfo* GameInfo::add_player_infos() {
  // @@protoc_insertion_point(field_add:network.GameInfo.player_infos)
  return player_infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >*
GameInfo::mutable_player_infos() {
  // @@protoc_insertion_point(field_mutable_list:network.GameInfo.player_infos)
  return &player_infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >&
GameInfo::player_infos() const {
  // @@protoc_insertion_point(field_list:network.GameInfo.player_infos)
  return player_infos_;
}

// -------------------------------------------------------------------

// Talk

// optional string txt = 1;
inline bool Talk::has_txt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Talk::set_has_txt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Talk::clear_has_txt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Talk::clear_txt() {
  txt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_txt();
}
inline const ::std::string& Talk::txt() const {
  // @@protoc_insertion_point(field_get:network.Talk.txt)
  return txt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Talk::set_txt(const ::std::string& value) {
  set_has_txt();
  txt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.Talk.txt)
}
inline void Talk::set_txt(const char* value) {
  set_has_txt();
  txt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.Talk.txt)
}
inline void Talk::set_txt(const char* value, size_t size) {
  set_has_txt();
  txt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.Talk.txt)
}
inline ::std::string* Talk::mutable_txt() {
  set_has_txt();
  // @@protoc_insertion_point(field_mutable:network.Talk.txt)
  return txt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Talk::release_txt() {
  // @@protoc_insertion_point(field_release:network.Talk.txt)
  clear_has_txt();
  return txt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Talk::set_allocated_txt(::std::string* txt) {
  if (txt != NULL) {
    set_has_txt();
  } else {
    clear_has_txt();
  }
  txt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txt);
  // @@protoc_insertion_point(field_set_allocated:network.Talk.txt)
}

// -------------------------------------------------------------------

// Error

// required int32 id = 1;
inline bool Error::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Error::id() const {
  // @@protoc_insertion_point(field_get:network.Error.id)
  return id_;
}
inline void Error::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:network.Error.id)
}

// required int32 dst_id = 2;
inline bool Error::has_dst_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_dst_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_dst_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_dst_id() {
  dst_id_ = 0;
  clear_has_dst_id();
}
inline ::google::protobuf::int32 Error::dst_id() const {
  // @@protoc_insertion_point(field_get:network.Error.dst_id)
  return dst_id_;
}
inline void Error::set_dst_id(::google::protobuf::int32 value) {
  set_has_dst_id();
  dst_id_ = value;
  // @@protoc_insertion_point(field_set:network.Error.dst_id)
}

// repeated int32 args = 3;
inline int Error::args_size() const {
  return args_.size();
}
inline void Error::clear_args() {
  args_.Clear();
}
inline ::google::protobuf::int32 Error::args(int index) const {
  // @@protoc_insertion_point(field_get:network.Error.args)
  return args_.Get(index);
}
inline void Error::set_args(int index, ::google::protobuf::int32 value) {
  args_.Set(index, value);
  // @@protoc_insertion_point(field_set:network.Error.args)
}
inline void Error::add_args(::google::protobuf::int32 value) {
  args_.Add(value);
  // @@protoc_insertion_point(field_add:network.Error.args)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Error::args() const {
  // @@protoc_insertion_point(field_list:network.Error.args)
  return args_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Error::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:network.Error.args)
  return &args_;
}

// -------------------------------------------------------------------

// Gossip

// optional .network.GossipType type = 1;
inline bool Gossip::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gossip::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gossip::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gossip::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::network::GossipType Gossip::type() const {
  // @@protoc_insertion_point(field_get:network.Gossip.type)
  return static_cast< ::network::GossipType >(type_);
}
inline void Gossip::set_type(::network::GossipType value) {
  assert(::network::GossipType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:network.Gossip.type)
}

// optional string txt = 2;
inline bool Gossip::has_txt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gossip::set_has_txt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gossip::clear_has_txt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gossip::clear_txt() {
  txt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_txt();
}
inline const ::std::string& Gossip::txt() const {
  // @@protoc_insertion_point(field_get:network.Gossip.txt)
  return txt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Gossip::set_txt(const ::std::string& value) {
  set_has_txt();
  txt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.Gossip.txt)
}
inline void Gossip::set_txt(const char* value) {
  set_has_txt();
  txt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.Gossip.txt)
}
inline void Gossip::set_txt(const char* value, size_t size) {
  set_has_txt();
  txt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.Gossip.txt)
}
inline ::std::string* Gossip::mutable_txt() {
  set_has_txt();
  // @@protoc_insertion_point(field_mutable:network.Gossip.txt)
  return txt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Gossip::release_txt() {
  // @@protoc_insertion_point(field_release:network.Gossip.txt)
  clear_has_txt();
  return txt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Gossip::set_allocated_txt(::std::string* txt) {
  if (txt != NULL) {
    set_has_txt();
  } else {
    clear_has_txt();
  }
  txt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txt);
  // @@protoc_insertion_point(field_set_allocated:network.Gossip.txt)
}

// optional uint32 id = 3;
inline bool Gossip::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gossip::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gossip::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gossip::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Gossip::id() const {
  // @@protoc_insertion_point(field_get:network.Gossip.id)
  return id_;
}
inline void Gossip::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:network.Gossip.id)
}

// -------------------------------------------------------------------

// HeartBeat

// -------------------------------------------------------------------

// PollingRequest

// required string object = 1;
inline bool PollingRequest::has_object() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PollingRequest::set_has_object() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PollingRequest::clear_has_object() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PollingRequest::clear_object() {
  object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_object();
}
inline const ::std::string& PollingRequest::object() const {
  // @@protoc_insertion_point(field_get:network.PollingRequest.object)
  return object_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PollingRequest::set_object(const ::std::string& value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:network.PollingRequest.object)
}
inline void PollingRequest::set_object(const char* value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:network.PollingRequest.object)
}
inline void PollingRequest::set_object(const char* value, size_t size) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:network.PollingRequest.object)
}
inline ::std::string* PollingRequest::mutable_object() {
  set_has_object();
  // @@protoc_insertion_point(field_mutable:network.PollingRequest.object)
  return object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PollingRequest::release_object() {
  // @@protoc_insertion_point(field_release:network.PollingRequest.object)
  clear_has_object();
  return object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PollingRequest::set_allocated_object(::std::string* object) {
  if (object != NULL) {
    set_has_object();
  } else {
    clear_has_object();
  }
  object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object);
  // @@protoc_insertion_point(field_set_allocated:network.PollingRequest.object)
}

// repeated string options = 2;
inline int PollingRequest::options_size() const {
  return options_.size();
}
inline void PollingRequest::clear_options() {
  options_.Clear();
}
inline const ::std::string& PollingRequest::options(int index) const {
  // @@protoc_insertion_point(field_get:network.PollingRequest.options)
  return options_.Get(index);
}
inline ::std::string* PollingRequest::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:network.PollingRequest.options)
  return options_.Mutable(index);
}
inline void PollingRequest::set_options(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:network.PollingRequest.options)
  options_.Mutable(index)->assign(value);
}
inline void PollingRequest::set_options(int index, const char* value) {
  options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:network.PollingRequest.options)
}
inline void PollingRequest::set_options(int index, const char* value, size_t size) {
  options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:network.PollingRequest.options)
}
inline ::std::string* PollingRequest::add_options() {
  // @@protoc_insertion_point(field_add_mutable:network.PollingRequest.options)
  return options_.Add();
}
inline void PollingRequest::add_options(const ::std::string& value) {
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:network.PollingRequest.options)
}
inline void PollingRequest::add_options(const char* value) {
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:network.PollingRequest.options)
}
inline void PollingRequest::add_options(const char* value, size_t size) {
  options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:network.PollingRequest.options)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PollingRequest::options() const {
  // @@protoc_insertion_point(field_list:network.PollingRequest.options)
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PollingRequest::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:network.PollingRequest.options)
  return &options_;
}

// -------------------------------------------------------------------

// PollingResponse

// optional uint32 option = 1;
inline bool PollingResponse::has_option() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PollingResponse::set_has_option() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PollingResponse::clear_has_option() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PollingResponse::clear_option() {
  option_ = 0u;
  clear_has_option();
}
inline ::google::protobuf::uint32 PollingResponse::option() const {
  // @@protoc_insertion_point(field_get:network.PollingResponse.option)
  return option_;
}
inline void PollingResponse::set_option(::google::protobuf::uint32 value) {
  set_has_option();
  option_ = value;
  // @@protoc_insertion_point(field_set:network.PollingResponse.option)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace network

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::network::JoinTeamRequest_Team> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::network::JoinTeamRequest_Team>() {
  return ::network::JoinTeamRequest_Team_descriptor();
}
template <> struct is_proto_enum< ::network::ReadyForGameRequest_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::network::ReadyForGameRequest_Type>() {
  return ::network::ReadyForGameRequest_Type_descriptor();
}
template <> struct is_proto_enum< ::network::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::network::MessageType>() {
  return ::network::MessageType_descriptor();
}
template <> struct is_proto_enum< ::network::GossipType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::network::GossipType>() {
  return ::network::GossipType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_base_2eproto__INCLUDED
